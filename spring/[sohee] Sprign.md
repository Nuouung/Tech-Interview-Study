# 왜 Framework를 사용하는가?

- 프레임워크 vs 라이브러리
    - 프레임워크 : 개발자가 프레임워크 안에서 개발하는 방식
    - 라이브러리 : 개발자가 호출해서 사용하는 방식
    - 차이
        - 프레임워크는 전체적인 흐름을 주도하고 개발자가 그 위에서 필요한 코드를 짠다. 라이브러리는 개발자가 전체적인 흐름을 만들며 라이브러리를 가져다 쓴다.
        - 라이브러리는 톱, 망치, 삽 같은 연장이다. 사람이 들고 썰고 바꿔 들고 내리치고 하는 행위를 할 수 있다. 사람이 도구를 선택하기 때문에 어떤 도구를 사용하든 원하는 기능을 할 수 있기만 하면된다. 땅을 팔 때 톱으로 파도 된다.
            
            프레임워크는 차, 비행기, 배같은 탈 것이다. 사람이 타서 운전하거나 조종해야한다. 탈 것은 정해진 목적에 맞게 잘 사용해야 한다.  
            
- 효율성 때문이다. 처음부터 모든걸 만드는 것보다 남이 만들어 놓은 것을 사용하는게 훨씬 빠르고 성능이 좋다. 그리고 개발할 때 개인이 미치는 영향을 최소화 해 일정한 품질을 보장할 수 있다.

# Spring이란?

- 엔터프라이즈( Enterprise : 대규모 사업, 기업 )급 애플리케이션을 개발하기 위한 기능을 제공하는 Framework입니다.

# 왜 Spring을사용하는가?

- Spring은 애플리케이션을 구축하기위한 경량화된 솔루션을 제공하여 효율적인 개발 환경을 제공한다.
- 개발자가 기본적인 디자인 패턴(DI, AOP, 서비스 추상화)등을 강제적으로 사용하게끔 함으로서 최소한의 코드 퀄리티를 보장한다
- 객체에 관여하지 않아도 된다. IoC 컨테이너에게 그 권한을 위임하여 우리는 핵심 비즈니스 로직에 더욱 집중할 수 있게 된다.
- Spring은 많은 기능들을 제공 하지만 모듈화되어 있어 필요한 모듈들을 선택적으로 사용 할 수 있다.
- 오픈소스로써, 오랜시간동안 성공적인 프레임워크로써 진화해 왔다.

# Spring 주요 특징

- 자바 객체를 직접 Spring 안에서 관리합니다. 객체의 생성 및 소멸과 같은 생명 주기(Life cycle)을 관리하며, Spring 컨테이너에서 필요한 객체를 가져와 사용합니다.
- POJO(Plain Old Java Object) 기반의 구성
    
    관계를 구성할 때 POJO의 구성만으로 가능하도록 제작 되어 있음. 자바 코드를 이용해서 객체를 구성하는 방식을 그대로 스프링에서 사용할 수 있음. 생산성에 유리하고, 코드에 대한 테스트 작업 역시 좀 더 유연하게 할 수 있다는 장점이 생긴다.
    
- 제어의 역전 (IOC, Inversion Of Control)
객체의 생성을 특별한 관리 위임 주체에게 맡깁니다. 이 경우 사용자는 객체를 직접 생성하지 않고, 객체의 생명주기를 컨트롤하는 주체는 다른 주체가 됩니다. 즉, 사용자의 제어권을 다른 주체에게 넘기는 것을 IOC(제어의 역전) 라고 합니다.
요약하면 Spring의 Ioc란 클래스 내부의 객체 생성 -> 의존성 객체의 메소드 호출이 아닌, 스프링에게 제어를 위임하여 스프링이 만든 객체를 주입 -> 의존성 객체의 메소드 호출 구조입니다. 스프링에서는 모든 의존성 객체를 스프링이 실행될때 만들어주고 필요한 곳에 주입해줍니다.
- 의존성 주입(DI-Dependency Injection)을 통한 객체 간의 관계 구성
    
    어떤 객체(B)를 사용하는 주체(A)가 객체(B)를 직접 생성하는게 아니라 객체를 외부(Spring)에서 생성해서 사용하려는 주체 객체(A)에 주입시켜주는 방식입니다. 사용하는 주체(A)가 사용하려는 객체(B)를 직접 생성하는 경우 의존성(변경사항이 있는 경우 서로에게 영향을 많이 준다)이 높아집니다. 하지만, 외부(Spring)에서 직접 생성하여 관리하는 경우에는 A와 B의 의존성이 줄어듭니다
    
- AOP(Aspect Oriented Programming)의 지원
    
    보안이나 로그, 트랜잭션과 같이 비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을 스프링에서는 '횡단 관심사(Cross-concern)라고 하고, AOP는 이러한 횡단 관심사를 모듈로 분리하는 프로그래밍의 패러다임
    

# Bean

- Spring이 제어권을 가지고 직접 만들며 관계를 부여하는 Object
- IoC Container에 의해 관리되는 자바 객체 (Object)

# POJO [ **Plain Old Java Object** ]

- 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않게 설계된 오브젝트
    - 미리 지정된 클래스를 extends 하는 것, 미리 정의된 인터페이스를 implement 하는 것., 미리 정의된 Annotation을 포함하는 것을 하면 안된다
- 왜 지향해야 하는가?
    - 스프링 프레임워크 이전에는 원하는 엔터프라이즈 기술이 있다면 그 기술을 직접적으로 사용하는 객체를 설계했습니다. 특정 기술과 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생겼습니다. 또한, 특정 기술의 클래스를 상속받거나, 직접 의존하게 되어 확장성이 매우 떨어지는 단점이 있었습니다. 이 말은 객체지향의 화신인 자바가 객체지향 설계의 장점들을 잃어버리게 된 것입니다.

# AOP [ **Aspect-Oriented Programming** ]

- 부가 기능을 핵심 코드로부터 분리해 모듈화하는 프로그래밍 방법 (모듈화:어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것 )
- 트랜잭션, 로깅, 성능 분석
- 용어
    - Target
        
        부가 기능을 부여할 대상
        
    - Aspect
        
        부가기능 모듈 
        
        부가 기능을 정의한 advice와 advice의 적용 위치를 결정하는 pointcut을 포함한다 
        
    - Advice
        
        부가 기능을 담은 구현체 
        
        Aspect가 무엇을 언제 할지를 정의
        
        - AOP 적용 타입
            - **@Before**
                
                Advice 의 Target 메서드가 호출되기 전에 실행되는 Advice 입니다.
                
            - **@After**
                
                Advice 의 Target 메서드가 호출된 후에 그 결과에 상관없이(성공 or 실패) 실행되는 Advice 입니다.
                
            - **@AfterReturning**
                
                Target 메서드가 정상적으로 실행된 후에 실행되는 Advice 입니다.
                
            - **@AfterThrowingAdvice**
                
                Target 메서드가 수행도중 예외가 발생했을 때 예외를 던지게 되면 실행되는 Advice 입니다.
                
            - **@Around**
                
                타겟 메서드를 감싸서 특정 Advice를 실행한다. @Around 는 ProceedingJoinPoint 의 proceed() 를 수행하는데, proceed() 의 리턴 값이 sub 메서드의 리턴 값이다. 즉, @Advice 내부에서 결과값을 제어할 수 있다.
                
    - JoinPoint
        
        Advice가 적용될 수 있는 위치 
        
    - PointCut
        
        Advice를 적용할 JoinPoint들을 정의한 것 
        
    - Proxy
        
        Target 을 랩핑하여 Target 의 요청을 대신 받아주는 오브젝트
        
    - Weaving
        
        지정된 객체에 Aspect 를 적용해서 새로운 프록시 객체를 생성하여 적용하는 것을 말합니다. 
        
        즉, 공통 코드를 핵심 로직 코드에 삽입하는 과정
        
- AOP 적용 방법
    - 컴파일 : 자바 파일을 클래스 파일로 만들 때 바이트코드를 조작하여 적용된 바이트코드를 생성
    - 로드 타임 : 컴파일은 원래 클래스 그대로 하고, 클래스를 로딩하는 시점에 끼워서 넣는다.
    - 런타임 : A 클래스 타입의 Bean을 만들 때 A 타입의 Proxy Bean을 만들어 Proxy Bean이 Aspect 코드를 추가하여 동작 → 스프링 AOP가 사용
- 프록시 기반의 AOP 구현체이다. 프록시 객체를 사용하는 이유는 접근 제어 및 부가 기능을 추가하기 위해서이다.
    
    클라이언트에서 타겟을 호출하게 되면 타겟이 아닌 타겟을 감싸고 있는 프록시가 호출되어, 타겟 메소드 실행전에 선처리, 타겟 메소드 실행 후, 후처리를 실행시키도록 구성되어있다.
    
- 스프링 빈에만 AOP를 적용할 수 있다.
- 어떤 클래스가 Spring AOP의 대상이라면 그 기존 클래스의 빈이 만들어질때,Spring AOP가 프록시(기능이 추가된 클래스)를 자동으로 만들고 원본 클래스 대신 프록시를 빈으로 등록한다. 그리고 원본 클래스가 사용되는 지점에서 프록시를 대신 사용한다. 즉, Spring AOP 에서는 Dynamic Proxy 기법을 이용해서, Proxy 클래스를 덧씌워 AOP 를 구현한다.
    
    → 이러한 방식이 가능한 이유는 프록시 구현 대상(RateDiscountService)이 인터페이스(DiscountService)를 구현하고 있으며, Spring이 프록시 구현체(RateDiscountServiceProxy)를 만들때 프록시 대상과 동일한 인터페이스(DiscountService)를 구현하도록 했기 때문이다. 즉, 프록시 대상(RateDiscountService)과 프록시 구현체(RateDiscountServiceProxy) 모두 동일한 인터페이스(DiscountService) 타입 및 구현체이기 때문에 기존의 RateDiscountService 빈을 RateDiscountServiceProxy로 바꿔치기 하고, 빈 후처리기를 통해 이미 정의된 의존 관계 역시 바꿀 수 있는 것이다.
    
- 스프링 AOP에서는 런타임시에 Weaving을 통해서 프록시 객체를 생성하게 됩니다.
생성방식으로는 첫번째로 JDK Dynamic Proxy가 있는데 타겟대상이 Interface를 구현하는 클래스면 인터페이스를 기반으로 프록시 객체를 생성합니다.두번째로는 CGLIB가 있는데 타켓대상이 인터페이스를 구현하고 있지 않고 바로 클래스를 사용한다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성합니다. CBLIB는 대상 클래스를 상속받아 구현합니다.

# IOC [ **Inversion of Control** ]

- "제어의 역전" 이라는 의미로, 개발자가 의존 관계를 직접 제어하지 않고 객체의 생명주기 관리, 흐름 제어를 컨테이너에게 맡깁니다. 객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있다
- 기존의 Java Programming 에서는 Class를 생성하고 new를 입력하여 원하는 객체를 직접 생성한 후에 사용했었습니다. 하지만 Spring에서는 직접 new를 이용하여 생성한 객체가 아니라, Spring에 의하여 관리당하는 자바 객체를 사용합니다.
- 왜 IoC를 Spring에서 사용했을까?
    - Spring은 Framework이기 때문에 흐름을 직접 핸들링 해줘야 합니다. 그래서 적합한 모델, 패턴을 적용해야 했고 Framework에 적합한 IoC, DI 개념 모델이 들어가게 되었다.
    - 객체를 관리해주는 컨테이너와 비즈니스 로직을 분리해 서로의 역할을 충실히 하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다.

# IoC Container / DI Container

- 객체(Bean)의 생성을 책임지고, 의존성을 관리하는 컨테이너입니다
- 사용자가 작성한 메타 데이터(xml 또는 @Component / @Configuration과 @Bean Annotation)에 따라 bean 클래스를 생성 및 관리하는 컨테이너
- 종류
    - BeanFactory
        - Bean을 등록, 생성, 조회, 소멸을 관리하는 컨테이너
        - BeanFactory는 바로 사용되지 않고 좀 더 확장된 ApplicationContext를 사용한다.
    - ApplicationContext ← 주로 사용
        - BeanFactory인터페이스를 상속
        - AOP, Message Handling, Event handling과 같은 추가적인 기능을 제공

# DI [ Dependency Injection ]

- 의존성 : 서로 다른 객체간에 레퍼런스 참조가 되어 있다. A -> B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조
- IoC 구현 기법으로 외부(스프링컨테이너)로부터 객체의 주소(레퍼런스) 값을 전달 받아 객체가 참조 되어지는 방식입니다.  A 객체에서 B객체를 사용할 때 A 객체에서 B객체를 직접 생성 하는 것이 아니라 외부(IOC컨테이너)에서 생성된 B객체를 setter 혹은 생성자를 통해 주입시켜 사용하는 방식입니다. 클래스에서 직접 생성하는 것이 아닌 외부에서 사용할 때 주입해줌으로서, 객체 간의 결합도를 줄이고 좀 더 유연한 코드를 작성할 수 있습니다.
- 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다
- 의존성의 문제점
    - unit test가 어려워진다
    - code 변경이 어려워진다
- 사용 이유
    - 재사용성 높힘
    - 코드 단순화
    - 종속성 감소
