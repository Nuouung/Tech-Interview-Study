# DDL, DML, DCL, TCL

- DDL :  테이블 구조를 정의하는데 사용되는 명령어들 ex) CREATE, ALTER, DROP, RENAME, TRUNCATE
- DML : 데이터 조회/변형을 가하는 명령어들 ex) SELECT, INSERT, UPDATE, DELETE
- DCL : DB에 권한과 관련된 명령어들 ex) GRANT, REVOKE
- TCL : 트랜잭션을 제어하는 명령어들 ex) COMMIT, ROLLBACK, SAVEPOINT

# Key

- 기본키 : 중복 될 수 없고 null이 될 수 없는 키
- 외래키 : 다른 테이블의 기본키를 참조하는 키

# JOIN

- 두 개 이상의 테이블이나 데이터베이스를 연결해 데이터를 검색하는 방법
- 테이블을 연결하려면, 적어도 하나의 칼럼을 서로 공유하고 있어야 한다

# 트랜잭션

- 데이터베이스의 상태를 변화시키는 작업 단위
    
    트랜잭션에는 여러 개의 연산이 수행될 수 있고, 수행중에 한 작업이라도 실패하면 전부를 rollback하고 모두 성공해야 commit한다.
    
- 트랜잭션의 목적은 사용자가 데이터베이스의 완전성 (Integrity)를 유지하기 위함이다. (다른 말로 데이터 부정합을 방지하기 위함이다)
- 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날리고 임시 영역(Rollback Segment)에 저장했던 상태로 rollback한다
- 트랜잭션의 길이가 길어지면 확실하게 오류가 발생하지 않은 부분도 처음부터 다시 작업을 수행해햐되는 비효율성 문제가 생긴다. 따라서 확실한 부분에 대해서는 rollback이 되지 않도록 Save Point (중간 저장 지점)을 지정한다. Save Point를 지정하면 rollback할 때 지정된 save point 이후부터 진행하게 된다.
- Commit : 하나의 트랜잭션이 성공적으로 끝났을 때 저장되지 않은 모든 데이터를 데이터베이스에 저장하고 현재의 트랜잭션을 종료하라는 명령
    
    Rollback : 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산
    

## ACID

- ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질이다.
- Atomicity(원자성) : 트랜잭션의 연산은 모두 반영되거나, 모두 반영되지 않아야 한다.  ( commit or rollback )
Consistency(일관성) : 트랜잭션을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지한다.
Isolation(고립성) : 둘 이상의 트랜잭션 수행시 수행중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다
Durability(내구성) : 트랜잭션이 커밋된 이후에는 시스템 오류가 발생하더라도 커밋된 상태로 유지되는 것을 보장해야 한다

# 격리수준 [Transaction Isolation Levels]

- 트랜잭션들끼리 얼마나 고립되어있는지를 나타내는 것으로 특정 트랜잭션이 다른 트랜잭션에 의해 변경된 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.
- 트랜잭션 격리 수준이 필요한 이유
    - 데이터베이스는 ACID로 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다. 그래서 트랜잭션이 데이터를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 Locking 이라는 개념이 등장했다. 하지만 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다. 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리 될 여지가 있다. 그래서 최대한 효율적인 Locking 방법이 필요하다
        - Lock : 여러 커넥션에서 동시에 동일한 레코드/테이블을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
    - 트랜잭션이 시작된 시점으로부터 일관성 있게 데이터를 읽어 들이는 것(트랜잭션 수준 읽기 일관성)을 지키기 위해서
- 종류
    - READ UNCOMMITTED (0)
        - 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있다
        - Dirty Read, Non-Repeatable Read, Phantom Read 현상이 발생
        - RDBMS 표준에서 격리수준으로 인정하지 않는다
    - READ COMMITTED (1)
        - 다른 트랜잭션에서 커밋한 내용만 참조할 수 있다.
        - 실제 테이블 값을 가져오는 것이 아니라 Undo 영역에 백업된 레코드에서 값을 가져온다
        - Non-Repeatable Read, Phantom Read 현상 발생
    - REPETABLE READ (2)
        - 트랜잭션을 시작하기 전에 커밋된 내용만 조회해 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
        - MySQL에서는 트랜잭션마다 트랜잭션 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽게 된다. 변경되기 전 레코드는 Undo 공간에 백업해두고 실제 레코드 값을 변경한다
        - 하나의 트랜잭션 실행시간이 길어질수록 Undo에 백업된 레코드가 많아져서 멀티 버전을 관리해야하는 단점이 있다.
        - 데이터 변경, 삭제는 불가능 하지만 데이터 추가는 가능
        - Phantom Read 현상 발생
    - SERIALIZABLE (3)
        - 트랜잭션에 완료될때까지 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다
        - 동시 처리 능력이 다른 격리수준보다 떨어지고 성능저하가 발생하여 데이터베이스에서 거의 사용되지 않는다.
- 발생할 수 있는 문제
    - Dirty Read (Uncommitted Dependency)
        - 변경 후 아직 Commit 되지 않은 값 읽고, Rollback 후의 값을 다시 읽어 최종 결과 값이 상이한 현상이다
    - Non-Repeatable Read (Inconsistent Analysis)
        - 한 트랜잭션 내에서 동일한 SELECT를 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정해 비 일관성이 발생하는 것
    - Phantom Read
        - 하나의 트랜잭션에서 같은 쿼리를 두 번 실행했을 경우, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상이다.
        - 이를 방지하기 위해서는 쓰기 잠금 (write lock)을 걸어야 한다
- 여러 커넥션에서 동시에 동일한 레코드/테이블을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할

# 고립성 보장

- 고립성 보장 방법
    - 데이터를 읽을 때, 여러 트랜잭션이 읽을 수 있도록 허용하는 shared_lock (공유 락)을 사용한다. (데이터 쓰기는 허용하지 않고 읽기만 가능)
    - 데이터를 쓸 때, 다른 트랜잭션이 읽지도 쓰지도 못하도록 하는 exclusive_lock (배타 락)을 사용한다.

# 인덱스

![https://media.vlpt.us/images/guswns3371/post/dcb61735-e5a1-46f3-a206-89898a4ec9e0/image.png](https://media.vlpt.us/images/guswns3371/post/dcb61735-e5a1-46f3-a206-89898a4ec9e0/image.png)

- DB의 검색 속도를 향상시키기 위한 자료구조
- 인덱스를 생성하면 데이터+주소를 저장하기 위한 별도의 메모리 공간이 필요하고 추가, 수정, 삭제 연산시에 인덱스를 처리하기 위한 추가적인 연산이 수행됩니다.
- 인덱스를 활용하여 데이터를 조회하면 인덱스에 저장된 데이터의 물리적 주소를 참조하여 데이터를 조회하므로 검색속도가 향상
- 인덱스를 사용하지 않은 Column을 조회할 경우 전체를 탐색 (Full Scan)해야 한다.
- SortedList는 DBMS의 인덱스와 같은 자료구조이며, ArrayList는 데이터 파일과 같은 자료구조를 이용한다
    
    SortedList 자료구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만, 이미 정렬돼 있어서 빨리 원하는 값을 찾아올 수 있다.
    
- 동작 방식
    
    동작 방식 : Index Table에서 where에 포함된 값을 검색 -> 해당 값의 table_id PK를 획득 -> 가져온 table_id PK값으로 원본 테이블에서 값을 조회
    
- 사용 이유
    - 검색할 때 데이터가 많다면 데이터를 찾기위해 많은 시간이 필요하다. 이때 도움이 되는게 인덱스 이다.
        
        자주 조회되는 Column 에 대한 Index Table을 따로 만들어 SELECT 문이 들어왔을 때 Index 테이블에 있는 값들로 결과 값을 조회해 온다. 그래서 Index를 잘 사용한다면 "검색" 연산을 실행했을 때 성능을 올릴 수 있게 된다. 
        
- 잦은 데이터의 변경(삽입, 수정 삭제)가 된다면 오히려 성능 저하가 일어날 수 있다.
    - DELETE : 테이블에서만 삭제되고 인덱스 테이블에는 사용안됨 표시만 해둠
    - UPDATE : DELETE 후 INSERT
- 사용하면 좋은 경우
    - JOIN, WHERE, ORDER BY 절에 자주 사용 / 고유한 값 / INSERT, DELETE, UPDATE 가 자주 발생하지 않은 Column
- 사용하면 안되는 경우
    - DATA 중복이 높음 / DML이 자주 발생하는 Column
- 사용이 불가능한 경우
    - 인덱스 컬럼을 조건절에서 가공 / 부정형 비교 / is null 조건
- 데이터 저장 방식(알고리즘)
    - Hash 알고리즘 : 컬럼의 값으로 해시 값을 계산해서 인덱싱. 동등 연산에 특화되어 있다. 값의 일부만 검색할 수 없다.
    - B-Tree
        
        ![https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcikell%2FbtqBRvDU1xF%2FCdIhvg8XEhHKaP23vE4Ju1%2Fimg.jpg](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcikell%2FbtqBRvDU1xF%2FCdIhvg8XEhHKaP23vE4Ju1%2Fimg.jpg)
        
        - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱 하는 알고리즘
        - 노드의 각 key 값에 따라서 작은 것은 왼쪽, 큰 것은 오른쪽에 위치해 빠르게 탐색이 가능하다
        - 각 노드마다 해당 키 값에 해당하는 데이터의 주소를 담고 있다
            
            리프 노드까지 내려가지 않아도 해당 키 값을 찾으면 바로 거기서 데이터 접근이 가능하다 
            
        - 가장 상단의 노드를 '루트 노드(Root Node)', 중간 노드들을 '브랜치 노드(Branch Node)', 가장 아래 노드들을 '리프 노드(Leaf Node)'라고 한다.
        - 데이터가 정렬된 상태로 유지되어 있다
        - B-Tree를 사용하는 이유
            
            인덱스를 사용하는 이유이기도 한데, 대부분 인덱스를 사용하는 이유는 쿼리 튜닝, 조회에 대한 효율을 높이기 위해서 사용한다. 그 말인 즉슨, 전체 데이터의 양이 크다면, 이를 얼마나 적은 범위로 탐색해서 데이터를 가져올거냐 이런 문제가 생긴다. 당연히 전체 데이터를 스캔할 필요가 없고, 균형트리에 적절하게 분산되어 저장이 되어있다면, 특정 범위로 조회했을때, 굳이 전체 스캔을 하지 않아도 된다. 그렇기 때문에 BTREE 자료 구조를사용한다.
            
        - B-Tree에 인덱스를 저장할 때는 저장될 키값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장. 만약 리프 노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 때문에 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이든다
    - B+Tree [  MySQL의 DB engine ]
        
        ![https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/db-btree.png](https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/db-btree.png)
        
        - B-Tree를 개선시킨 자료구조로, 브랜치 노드에 key만 담아두고, data는 담지 않는다. 오직 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked list로 연결되어 있다.
        - 검색은 루트노드에서 어떤 리프 노드에 이르는 한 개의 경로만 검색하면 되므로 매우 효율적이다.
        - 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리에 효율적이다
        - 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있어서 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다.
- 구조
    - 클러스터 인덱스
        - 테이블 1개만 허용되며, 해당 컬럼을 기준으로 테이블이 정렬된다
        - PK 설정 시 자동으로 생성된다
        - 정렬되어 있기 떄문에 Range 쿼리에 효율이 좋다.
        - 어떤 경우에 생성해야할까?
            - 테이블 데이터가 자주 업데이트 되지 않는 경우
            - 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
            - 읽기 작업이 많은 경우
    - 논클러스터 인덱스 / 보조 인덱스
        
        ![https://user-images.githubusercontent.com/49560745/107178655-f446ba00-6a17-11eb-8f5d-06217ad3d901.png](https://user-images.githubusercontent.com/49560745/107178655-f446ba00-6a17-11eb-8f5d-06217ad3d901.png)
        
        - 중복된 값을 가지며 한 테이블에 여러 개를 생성 할 수 있다.
        - 테이블 데이터와 함께 테이블에 저장되는 것이 아니라 별도의 장소에 저장되며 인덱스 키 값과 데이터 행을 가리키는 포인터가 존재한다.
        - 테이블이 물리적으로 정렬되어 있지 않다
        - 조회 성능을 향상시키기 위해 특정 컬럼들의 조합으로 인덱스를 생성한다
        - 어떤 경우에 생성해야할까?
            - where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자할 때
            - 데이터가 자주 업데이트 될 때
            - 특정 컬럼이 쿼리에서 자주 사용 될 때
        - 종류
            - 단일 인덱스
                - 인덱스에 컬럼이 하나만 걸려있는 경우
                - 데이터가 많지 않고 조건에 걸리는 컬럼이 적은 경우에 사용
            - 복합 인덱스
                - 인덱스에 컬럼이 두 개 이상 걸려 있는 경우
                - 데이터가 많고 조건에 걸리는 컬럼이 많은 경우에 사용
                - 첫 번째 칼럼에 대해 우선 정렬되고, 첫 번째 칼럼의 값이 같을 경우에만 두 번째 칼럼 정렬이 수행된다.
                    
                    그래서 인덱스 설정할 당시 칼럼의 순서가 상당히 중요하다.
                    
            - 커버드 인덱스
                - 쿼리가 인덱스 접근으로 인해 테이블 접근이 필요치 않은 경우

# 정규화

- 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업

# 데이터베이스 장애

- SQL Injection
    - 해커에 의해조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법을 말한다.

# 데이터베이스 회복 기법

# 옵티마이저(Optimizer)

- 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진
- 쿼리 처리 흐름
    1. 개발자가 SQL문을 작성합니다.
    2. 파서(Parser)는 개발자가 작성한 SQL문을 문법 검사와 구문 분석을 합니다.
    3. 옵티마이저는 여러 플랜을 생성하고 각종 통계정보를 기반으로 최소 비용의 실행계획을 결정합니다.
    4. SQL 실행 엔진이 옵티마이저가 결정한 실행계획대로 데이터를 처리하여 사용자에게 결과를 전달합니다.

# Hint

- Optimizer라고 해서 항상 최선의 실행계획을 수립할 수는 없으므로 테이블이나 인덱스의 잘못된 실행 계획을 개발자가 직접 바꿀 수 있도록 도와주는 것

# Replication

- 두 개의 이상의 DBMS 시스템을 Mater / Slave 로 나눠서 동일한 데이터를 저장하는 방식
- 사용 목적 : 데이터 백업, 분산처리
- master는 갱신 쿼리를 처리하고 바이너리 로그파일로 기록한다. 이 로그파일의 내용이 slave로 전송되고 순차적으로 실행함으로써 복제된다

# 파티셔닝(Partitioning)

- 큰 table이나 index를,  partition이라는 작은 단위로 물리적으로 분할하는 것
- 데이터베이스를 분산 처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 되었다
- 목적
    - 성능 향상 : Full Scan에서 데이터 Access의 범위를 줄인다, 많은 INSERT가 있는 시스템에서 INSERT 작업을 partition들로 분산시켜 경합을 줄인다.
    - 가용성 향상 : 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어든다
    - 관리 용이성 : 큰 table들을 제거하여 관리를 쉽게 해준다

# 샤딩(Sharding)

- 방법
    - DB가 저장하고 있는 테이블을 테이블 단위로 분리
    - 테이블 자체를 분할

# SQL vs NoSQL

- SQL 
    - 데이터는 정해진 테이블 구조를 따라 데이터베이스 테이블에 저장된다.
    - 데이터의 중복을 피하기 위해 '관계'를 이용한다. 테이블 간의 관계를 나타내기 위해 외래 키(foreign key)를 사용한다.
    - 대체로 Scale-Up
    - 언제 사용해야 할까?
        - 명확한 스키마를 갖는게 중요한 경우
        - 관계를 맺고 있는 데이터가 자주 변경되는 경우
- NoSQL
    - 스키마가 없기 때문에 SQL보다 유연하게 데이터를 저장할 수 있다
    - 대량의 분산된 데이터를 저장하고 조회하는 데 특화되어있다.
    - 대체로 Scale-Out
    - 데이터가 중복되어 있기 때문에 데이터 수정 시 중복된 데이터 모두 업데이트를 수행해야 한다
    - 언제 사용해야 할까?
        - 정확한 데이터 구조를 알 수 없거나 구조가 변경/확장될 가능성이 있는 경우
        - read 처리를 자주하지만 update를 자주하지 않는 경우
        - 많은 양의 데이터로 인해 데이터베이스를 수평적으로 확장해야하는 경우
- 둘은 대체될 수 있는 것이 아니고, 각각 필요한 시점에 적절히 선택해서 사용해야 합니다. 둘 다 같이쓰는 상호보완적인 존재가 될 수도 있습니다

# Redis

- key-value 구조의 NOSQL DB입니다. 싱글스레드로 동작하며 다양한 자료구조와 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다
- 보통 데이터베이스는 하드 디스크나 SSD에 저장한다. 하지만 Redis는 메모리(RAM)에 저장해서 매우 빠르다
- Redis와 Memcached의 차이
    
    Redis는 싱글 스레드 기반으로 동작하고, Memcached는 멀티스레드를 지원해서 멀티 프로세싱이 가능합니다.
    
    Redis는 다양한 자료구조를 지원하고, Memcached는 문자열 형태로만 저장합니다.
    
    Redis는 여러 용도로 사용할 수 있도록 다양한 기능을 지원합니다.
    
    Redis는 스냅샷, AOF 로그를 통해서 데이터 복구가 가능합니다.
    

여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
