# 객체 관계 매핑(Object-relational mapping, ORM)

- 객체와 RDB의 데이터를 자동으로 매핑(연결)해주는 것
- 장점 = 왜 사용하는가?
    - 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.
    - 재사용 및 유지보수의 편리성이 증가한다.
    - 기본적인 기능의 SQL을 짤 필요없이 객체를 통해 DB를 조작할 수 있게 된다.
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다. 따라서 DBMS에 대한 종속성이 줄어든다.
- 단점
    - ORM 으로만 서비스를 구현하기가 어렵다

# JPA [Java Persistence API]

- 객체와 RDB를 매핑하는 표준 기술로 인터페이스들의 모임이다.
- 구현된 클래스와 매핑을 해주기 위해 주로 Hibernate를 사용한다.
- 특징
    - 객체 중심 개발 - SQL문이 아닌 Method를 통해 DB를 조작할 수 있다
    - 생산성 증가 - 반복적인 CRUD를 메소드를 통해 쉽게 해결할 수 있다.
    - 유지보수 용이 - 쿼리 수정이 필요할 때, 이를 담아야 할 DTO 필드도 모두 변경해야 하지만 JPA는 엔티티 클래스 정보만 변경하면 된다
    - 성능 증가 - JPA는 동일한 쿼리에 대한 캐시 기능을 지원
- 엔티티
    - DB 테이블에 대응하는 클래스
    - @Entity가 붙은 클래스는 JPA에서 관리하며 엔티티라고 한다
- 엔티티 매니저 팩토리
    - 엔티티 매니저 인스턴스를 관리하는 주체이다. 애플리케이션 실행 시 한 개만 만들어지며 사용자로부터 요청이 오면 엔티티 매니저 팩토리로부터 엔티티 매니저를 생성한다.
- 엔티티 매니저
    - 영속성 컨텍스트에 접근하여 엔티티에 대한 데이터베이스 작업을 제공한다. 내부적으로 데이터베이스 커넥션을 사용해서 데이터베이스에 접근한다.
    - 메소드
        - find() : 영속성 컨텍스트에서 엔티티를 검색하고 영속성 컨텍스트에 없을 경우 데이터베이스에서 데이터를 찾아 영속성 컨텍스트에 저장한다.
        - persist() : 엔티티를 영속성 컨텍스트에 저장한다. → 1차 캐시에 저장되는 것과 동시에 쓰기 지연 SQL 저장소에 SQL문이 저장된다
        - remove() : 엔티티 클래스를 영속성 컨텍스트에서 삭제한다.
        - flush() : 영속성 컨텍스트에 저장된 내용을 데이터베이스에 반영한다.

# ****영속성 컨텍스트란?****

- 엔티티를 영구 저장하는 환경으로, 애플리케이션과 DB사이에서 객체를 보관하는 가상의 환경이다.
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근 하고 엔티티를 관리한다.
- 엔티티를 @Id(기본키)로 구분하기 때문에 영속 상태는 반드시 식별자를 가지고 있어야만 한다.
- 장점
    - 엔티티의 동일성을 보장
    - 쓰기 지연 -> 트랜잭션 커밋시점에 쿼리 날라감
    - 변경 감지(더티 체킹) 기능
    - 지연 로딩 기능
- 1차 캐시
    - 영속성 컨택스트 내부에는 1차 캐시라고 불리는 캐시를 가지고 있다. 영속상태의 엔티티는 모두 1차 캐시에 저장된다. 엔티티를 조회할 때, 우선 1차 캐시에 해당 엔티티가 존재 하는지 @Id값으로 확인 한 후 엔티티가 존재할 경우 해당 엔티티를 반환하고, 엔티티가 없으면 데이터베이스에서 조회 후 1차 캐시에 저장 및 반환한다.
- 쓰기 지연
    - 영속성 컨텍스트는 삽입/삭제/수정과 같은 DML이 발생했을 때, 바로 데이터베이스에 반영하지않고, 트랜잭션을 커밋할 때, 모아둔 쿼리들을 한번에 데이터베이스 반영을 한다. 쿼리들은 영속성 컨텍스트의 쓰기지연SQL 저장소에 저장된다. 그리고 커밋을 실행 하면, flush -> commit 순서로 데이터베이스에 작업한다. flush는 쓰기지연SQL 저장소 쿼리들을 데이터베이스에 저장하는 것이고, commit은 데이터베이스에 쿼리들을 반영하는 것을 의미한다. 쓰기지연을 하면, 데이터베이스에 접근하는 횟수가 줄기 때문에 성능면에서 뛰어나다.

# ****엔티티의 상태(생명주기) / 영속성 컨텍스트의 속성****

- 비영속 : 영속성 컨텍스트와 관계 없는 상태
- 영속 : 영속성 컨텍스트에 관리되는 상태
- 준영속 : 영속성 컨텍스트에서 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

# JPA 동작 순서

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7ecd2224-bc8d-495b-88d6-a7096434f0be/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220408%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220408T145034Z&X-Amz-Expires=86400&X-Amz-Signature=d074987aeeac5bfd0b715fdca32cd9585ca7f660a1198d59e8781e5849ff4abf&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

- 개발자가 JPA 사용 > JPA 내부에서 JDBC API 사용 > SQL호출 > DB 통신

# JPQL [ Java Persistence Query Language ]

- 객체지향 쿼리로 JPA에서 제공하는 메서드 호출만으로 원하는 쿼리를 수행할 수 없을 때 사용한다.
- 엔티티를 조회하면 해당 엔티티는 영속성 컨텍스트에서 관리되고 엔티티가 아니라면 영속성 컨텍스트에서 관리되지 않는다.

# JPQL 동작 순서

1. JPQL을 호출하면 DB에 우선적으로 조회한다.
2. 조회한 값을 영속성 컨텍스트에 저장을 시도한다.
3. 해당 데이터가 이미 영속성 컨텍스트에 있다면 DB에서 조회한 신규 데이터를 버린다.

→  이렇게 함으로써 Isolation 레벨이 REPEATABLE READ 수준까지 올라가게 됩니다.

# 저장할 때 JPA 동작 과정

- JPA는 트랜잭션 실행 단위 안에서 동작한다. 객체를 생성하고 엔티티 매니저에 의해서 생성된 객체를 영속성 컨텍스트에 등록한다. 이때 해당 객체는 영속상태가 된다 즉 1차 캐시에 저장된다. 또한 insert 쿼리는 쓰기지연 SQL저장소에 저장이된다. 트랜잭션이 끝나는 시점에 쓰기 지연 SQL 저장소에 있는 쿼리문들이 flush가 되고 트랜잭션 커밋이 된다.

# 수정할 때 JPA 동작 과정

- 우선 수정할 엔티티를 찾는다. 이때 1차 캐시에 올라가고 영속상태가 된다. 즉 영속성 컨텍스트가 관리하는 상태가 된다. 그리고 데이터를 수정한다. 이때 JPA는 데이터베이스 트랜잭션 커밋 시점에 내부적으로 flush가 되는데 영속성 컨텍스트 기능중 변경감지 기능이 있어서 이 것이 현재 1차 캐시의 엔티티와 최소 1차 캐시에 등록된 상태의 스냅샷과 비교해서 변경내역을 확인하고 update 쿼리를 쓰기지연 저장소에 저장하고 트랜잭션 커밋 끝나기 전에 해당 쿼리를 날리고 커밋을 완료한다.

# JPA 영속성 컨텍스트의 이점(5가지)

- 1차 캐시
    - 영속성 컨택스트 내부에는 1차 캐시를 가지고 있는데 이를 통해  빠르게 조회가 가능하다. 1차 캐시에 없으면 그 때 DB에서 조회한다.
- 동일성 보장
    - 엔티티는 1차 캐시에서 가져오므로 여러 번 조회했을 때 식별자가 동일한 엔티티는 동일성이 보장된다.
- 쓰기 지연
    - 커밋이 되기 전까지는 쿼리문을 쓰기 지연 SQL 저장소에 모아뒀다가 커밋하는 시점에 한번에 flush한다. 쓰기지연을 하면 DB에 접근하는 횟수가 줄어 성능에 좋다
- 변경 감지(Dirty checking)
    - 엔티티를 1차 캐시에 처음 저장할 때 스냅샷을 찍어둔다. commit 되는 시점에 엔티티와 스냅샷과 비교해 변경된 엔티티가 존재하면 DB에 반영한다
    - 영속 상태의 엔티티에만 적용 된다
- 지연 로딩
    - 엔티티에서 해당 엔티티를 불러올 때 그 때 SQL을 날려 해당 데이터를 가져옵니다.
    - 프록시 : 실제 엔티티 대신에 사용되는 객체로 원본 엔티티를 상속받은 객체. DB로부터 조회가 되면 실제 객체가 연결이 되면서 최초에 1회 초기화된다.

# N+1 문제

- 하나의 쿼리를 수행하는데 N개의 쿼리가 더 수행된다는 의미이다.
- 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생
- JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에 발생한다.
- N + 1 쿼리 문제는 즉시 로딩과 지연 로딩 전략 각각의 상황에서 발생할 수 있다.
    - 즉시 로딩에서 발생하는 이유는 JPQL을 사용하는 경우 전체 조회를 했을 때, 영속성 컨텍스트가 아닌 데이터베이스에서 직접 데이터를 조회한 다음 즉시로딩 전략이 동작하기 때문입니다.
    - 지연 로딩에서 발생하는 이유는 지연로딩 전략을 사용한 하위 엔티티를 로드할 때, JPA에서 프록시 엔티티를 unproxy 할 때 해당 엔티티를 조회하기 위한 추가적인 쿼리가 실행되어 발생합니다.
- 해결 방법
    - Fetch Join 사용
        - 연관 엔티티까지 한 번의 쿼리로 가져올 수 있다
        - 페이징을 할 수 없다
        - 2개 이상의 OneToMany 자식 테이블에 Fetch join을 하면 MutipleBagFetchException이 발생
            
             → 자식 테이블을 지연 로딩으로 가져오고 batch_fetch_size를 설정
            
    - @EntityGraph를 사용
        - @EntityGraph 의 attributePaths에 같이 조회할 연관 엔티티명을 적는다다. 여러 개를 적을 수 있다
    - @Fetch(FetchMode.SUBSELECT)를 사용
    - @BatchSize를 활용
        - 설정한 size만큼의 데이터를 미리 로딩한다
        - 연관 엔티티를 조회할 때 size만큼 where in 쿼리를 통해 조회하고, size를 넘어갔을 때 추가로 where in 쿼리를 수행한다. 하지만 이 방법도 결국 정해진 batch size에 따라 반복적인 쿼리가 수행되니까 추천방안은 아니다.
- FetchJoin과 EntityGraph는 카테시안 곱(Cartesian Product)이 발생 하여 중복이 생기게 된다. -> 해결 방법 : JPQL에 DISTINCT 를 추가하여 중복 제거 / OneToMany 필드 타입을 Set으로 선언하여 중복 제거

# FetchType.EAGER, LAZY **즉시 로딩과 지연 로딩**

- FetchType : JPA에서 연관관계를 조회할 때 참조하는 객체들의 조회 시점을 선택할 수 있도록 해준다.
- 특정 엔티티를 조회할 때, 연관된 엔티티도 함께 조회하는 방식은 즉시로딩, 연관된 엔티티를 실제 사용할 때 조회되는 방식은 지연로딩이다.
- JPA 기본 패치 전략으로, 연관된 엔티티가 하나일 경우에는 (OneToOne, ManyToOne) 즉시로딩, 컬렉션일 경우에는 (OneToMany, ManyToMany) 지연로딩이다.
- 가급적이면 지연 로딩(LAZY Loading)만 사용하자. 즉시 로딩(EAGER Loading)은 JPQL에서 N+1 문제를 일으킨다.

# @Transactional

- JPA 에서 트랜잭션을 지원할 수 있는 어노테이션.
- 동작 과정

# Open Session In View

# **QueryDSL**

- IDE의 도움을 받을 수 있고 컴파일 타임에 오류를 잡을 수 있다
- 동적 쿼리가 가능해 다양한 조회가 가능

# JDBC

- Java에서 DB에 접속할 수 있게 하는 Java API.
- 장점 : JDBC Driver 만 따로 만들어준다면 종류 상관없이 어떤 RDBMS라도 연결가능.
- 단점 : 쿼리를 실행하기 전과 후에 연결 생성, 연결 닫기 등 많은 코드를 반복적으로 작성해야한다.
    
    

# ****MyBatis****

- 대표적인 SQL Mapper → SQL을 직접 작성하여 SQL문과 객체(Object)의 필드를 매핑하여 데이터를 객체화한다.
- 반복적인 JDBC 프로그래밍을 단순화, SQL 쿼리들을 XML 파일에 작성하여 코드와 SQL을 분리하여 관리. 동적 쿼리를 지원
- 장점 : 쿼리 수행 결과와 객체의 필드를 매핑할 수 있고 JDBC에서 반복적으로 했던 작업들을 대신해준다.
- 단점 : 개발자가 SQL문을 직접 작성하면서 발생하는 문제점을 피할수 없다. 테이블마다 비슷한 CRUD SQL 작업이 반복된다. 테이블 필드가 변경될 시 이와 관련된 모든 부분에서 SQL문, 객체의 필드를 수정해야 한다.
