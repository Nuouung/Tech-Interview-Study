### JDBC란?

* 자바 언어 환경에서 데이터베이스로의 연결 및 작업을 위한 자바 표준 인터페이스
* 자바는 DBMS의 종류에 상관없이 하나의 JDBC API를 이용해 데이터베이스 작업을 처리함
* 자바는 JDBC를 통해 애플리케이션에서 데이터베이스에 접근할 수 있음

### JDBC 관련 인터페이스

* JDBC Driver Manager: JDBC 아키텍처를 이루는 자바의 애플리케이션과 JDBC Driver의 접속을 공급
* JDBC Driver API: JDBC Driver Manager와 DBMS 벤더에서 제공하는 JDBC Driver가 서로 접속하기 위한 인터페이스
* JDBC Driver: DBMS에 접속하기 위한 모듈

### DBCP(Database Connection Pool)

* 웹 컨테이너(WAS)가 실행되면서 데이터베이스와 미리 연결해 놓은 객체들을 풀에 저장해 두었다가 클라이언트의 요청이 들어올 때 이를 사용하는 방식
* DB 연결에 필요한 connection을 미리 생성 -> 필요할 때 사용 -> 사용 후 pool에 반남
* 왜 사용? JDBC를 직접 연결해 사용하는 경우, 매 요청마다 JDBC Driver를 로드하고 connection 객체를 받아와야 함. 클라이언트의 요청이 들어올 때마다 생성 -> 연결 -> 종료를 하는 것은 매우 비효율적
* 그래서 DBCP를 사용해 만들어주고, 종료시키지 않고, pool에 넣어놔서 재사용하는 것.

### 영속성(Persistance)

* 데이터를 생성한 프로세스가 종료되더라도 정보가 사라지지 않는 '데이터'의 특성
* 메모리에 데이터를 저장하게 될 경우, 프로세스 종료 시 데이터는 모두 사라짐 (프로세스 종료 시 heap, stack, code, data 모두 사라짐)
* 데이터를 데이터베이스에 저장할 경우 프로세스가 종료되더라도 데이터가 유실되지 않음
* 데이터를 데이터베이스 혹은 파일에 저장하는 행위 = 데이터에 영속성을 부여하는 행위

### 영속성 레이어(Persistence Layer)

* 프로그램 아키텍처 수준에서, 데이터에 영속성을 부여하는 계층
* 아키텍처적인 관점에서 보면 Business logic과 데이터베이스 사이에 존재한다
* 자바에서는 JDBC를 통해 직접 구현이 가능하지만 일반적으로 '마이바티스', 'JPA'와 같은 영속성 프레임워크를 통해 개발이 이루어진다.

### 영속성 프레임워크(Persistence Framework)

* JDBC를 직접 구현하는 복잡함이나 번거로움 없이 간단하게 데이터베이스와 연동되는 시스템을 개발하기 위한 프레임워크를 의미
* SQL 문장으로 직접 데이터베이스의 데이터를 다루는 'SQL Mapper'와 객체를 통해 간접적으로 데이터베이스의 데이터를 다루는 'ORM'이 존재
* SQL Mapper의 대표적 예 - Mybatis
* ORM의 대표적 예 - JPA, Hibernate

### ORM 

* 객체(Object)와 관계형 데이터베이스(RDB: Relational DB)을 연결(Mapping)하는 것을 말함
* 객체와 관계형 데이터베이스를 ORM이 자동으로 연결해주기 때문에 객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스대로 설계할 수 있다.
* ORM은 내부적으로 JDBC를 사용해서 적절한 SQL을 자동으로 생성하는 식으로 동작
* (but ORM은 완벽하지 않아서 아주 복잡한 SQL은 사람이 직접 짜야한다.)

### ORM의 장점

* SQL문이 아닌 메소드를 통한 DB 조작이 가능 -> 개발자는 비지니스 로직을 구성하는데 집중할 수 있음
* 객체지향적인 코드 작성이 가능 -> 생산성이 증가할 수 있음
* 매핑하는 정보가 class로 명시되기 때문에 유지보수 및 리펙토링에 유리함 

### ORM의 단점

* 프로젝트의 규모가 크고 복잡해 설계가 잘못될 경우 속도 저하 및 일관성을 무너뜨리는 결과를 낳을 수 있음
* 복잡하고 무거운 쿼리는 ORM으로 구현하기 어려운 경우가 있기 때문에 결국 SQL문을 작성해야 할 수도 있음
* 러닝커브(학습곡선)이 높음 (배우기 어려움)

### JPA란

* 자바 진영에서 ORM 표준 기술로 사용되는 인터페이스의 모음
* 인터페이스의 모음이기 때문에 특정 구현체를 칭하는 말은 아님
* JPA를 구현한 대표적인 오픈소스가 Hibernate.
* JPA를 구현한 오픈소스 -> Hibernate, EclipseLink, DataNucleus ...
* 스프링을 사용할 경우, JPA를 한 단계 더 추상화시킨 Spring Data JPA를 사용할 수 있는데 많은 CRUD SQL을 자동으로 처리하기 때문에 개발 생산성에서 매우 유리할 수 있음

### Persistance Context(영속성 컨텍스트)

* 엔티티를 영구 저장하는 환경이라는 뜻
* 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 '가상의 데이터베이스'
* 영속성 컨텍스트는 Entity Manager에 의해 관리됨
* 영속성 컨텍스트는 눈에 보이지 않는 '논리적인 개념.' 실제로 애플리케이션 내에 또 하나의 데이터베이스가 생성되는 것이 아니다. (위에서 설명했듯 가상의 데이터베이스라고 생각하면 됨)
* JPA의 경우 영속성 컨텍스트는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 기능을 제공함

#### 1차 캐시

* 영속성 컨텍스트 내부에 존재하는 캐시(Map). 
* 영속 상태의 모든 엔티티는 1차 캐시 내에 저장됨 
* 영속성 컨텍스트에 의한 transaction이 지속될 경우 애플리케이션은 데이터를 데이터베이스가 아닌 1차 캐시에서 가져옴
* 객체의 동일성을 보장함
* 1차 캐시의 key: @Id로 매핑한 식별자
* 1차 캐시의 value: 엔티티

#### 쓰기 지연

* 엔티티가 영속성 컨텍스트 내에 저장될 때, 해당 엔티티가 바로 데이터베이스에 반영되지 않고 영속성 컨텍스트의 트랜잭션이 종료되는 시점에 query가 전송되는 것
* 영속성 컨텍스트 내에는 '쓰기 지연 SQL 저장소'가 존재 -> 트랜잭션이 종료되지 않으면 모든 쿼리를 쓰기 지연 SQL 저장소에 저장함 -> 트랜잭션이 종료될 때 쿼리를 전송

#### 변경 감지(dirty checking)

* 한 트랜잭션 내에서 발생하는 엔티티의 변경 사항을 감지하고 자동으로 update 해주는 것
* 영속성 컨텍스트의 1차 캐시 덕분에 가능한 기능으로, 1차 캐시에는 엔티티가 적재되는 순간을 기록하는 '스냅샷' 공간이 있음
* 트랜잭션이 종료되고 데이터베이스로 쿼리가 전송될 때 영속성 컨텍스트는 최초의 엔티티(스냅샷)과 트랜잭션이 종료될 때의 엔티티를 비교해 변경 사항이 있으면 변경 정보를 update 쿼리로 만들어 전송함

#### 지연 로딩

* JPA는 엔티티가 실제로 사용되기 전까지 데이터베이스 조회를 지연함
* 즉, 실제 엔티티가 사용될 때 데이터베이스에서 필요한 데이터를 가지고 오는 것
* 이를 위해 내부적으로 프록시 객체가 사용되는데 프록시 객체는 객체의 정보가 담겨 있지 않은 껍데기 객체라고 생각하면 된다.

### 엔티티의 생명주기

* 비영속(new/transient): 영속성 컨텍스트와 전혀 관계 없는 상태(영속성 컨텍스트 외부에 존재)
* 영속(managed): 영속성 컨텍스트에 저장된 상태 (비영속 상태에서 persist() 메소드를 호출해 영속화할 수 있다)
* 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 <- 영속성 컨텍스트가 제공하는 어떠한 기능도 보장받을 수 없다!
* 삭제(removed): 삭제된 상태

### N+1 문제

* orm의 연관 관계에서 발생하는 이슈로 연관 관계가 얽힌 엔티티를 조회할 때, 연관된 엔티티의 갯수(N)만큼 추가적으로 조회 쿼리가 발생하는 것
* 한 개의 엔티티를 조회할 때, 연관된 N개의 엔티티가 추가적으로 조회되기 때문에 N+1 문제라고 한다

### N+1 문제를 해결하는 방법

* Fetch Join 사용 <- 두 테이블을 조인해서 한번에 모든 데이터를 가져온다. 페이징 기능을 이용할 수 없다는 단점이 있다.
* @EntityGraph 사용 <- attributePaths를 사용해 조회시 바로 가져올 필드명을 지정할 수 있다. 그러면 Lazy가 아닌 Eager로 조회하게 된다. (참고로 JoinFetch는 inner join, @EntityGraph는 outer join. 카테시안 곱이 발생할 수 있다 <- JPQL에 DISTINCT 키워드를 추가해 중복을 제거하거나 OneToMany 필드를 Set으로 선언해 중복을 제거할 수 있음)
* @BatchSize 사용 <- 설정한 size만큼의 데이터만 미리 로딩

### JPA: FetchType.EAGER과 FetchType.LAZY

* FetchType.EAGER(즉시 로딩)
  * 연관된 엔티티를 즉시 조회하기 위한 방법
  * 하이버네이트는 가능하면 SQL 조인을 이용에 한번에 조회함
  * 모든 엔티티를 즉시 조인하기 때문에 프록시 객체를 만들지 않고 실제 데이터를 그대로 가져온다
  * 결국 (필요해서 FetchType.EAGER을 사용하지 않는다는 가정 하에) 가져와야 하는 데이터가 매우 많은 경우 의도치 않은 성능저하가 발생할 수 있다. 
  * 특히 컬렉션을 즉시 로딩할 경우 항상 Outer Join을 사용하게 되는데 Outer Join은 Inner Join보다 성능 최적화상 불리하다. 따라서 컬렉션을 FetchType.EAGER로 조회할 때는 각별히 유의하자.
  * 즉시 로딩인 엔티티를 JQPL을 이용해 조회할 경우 N+1 문제가 발생한다
* FetchType.LAZY(지연 로딩)
  * 연관된 엔티티를 프록시로 조회하는 방법
  * 프록시를 실제 사용할 때 추가적인 쿼리로 실제 데이터를 조회함
  * 일반적으로 즉시 로딩보다 성능상 안전하기 때문에 모든 연관관계에는 지연 로딩이 사용되는 것이 권장된다고 한다. (이후 필요한 경우 특정 연관관계에 즉시 로딩을 사용해 성능을 최적화하는 방법을 사용하자)
* JPA의 기본 Fetch 전략
  * @ManyToOne, @OneToOne <- 즉시 로딩
  * @OneToMany, @ManyToMany <- 지연 로딩

### Mybatis란?

* 객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 쉽게 할 수 있도록 도와주는 개발 프레임워크
* JDBC를 통한 데이터베이스 접근을 캡슐화함
* 일반 SQL 쿼리문, 저장 프로시저 및 고급매핑을 지원
* 애플리케이션 내에 있는 SQL 쿼리문을 별도의 xml 파일로 분리할 수 있어 코드와 SQL을 분리할 수 있는 장점이 있음

### Mybatis의 특징

* 복잡한 쿼리나 다이나믹한 쿼리에 강함. <-> JPA의 경우 내부적으로 쿼리가 자동으로 만들어지기 때문에 복잡한 쿼리에 대응하기 어려움
* 애플리케이션의 비지니스 로직과 SQL 쿼리문이 분리되기 때문에 코드의 간결성 및 유지보수성이 향상됨
* resultType, resultClass 등 Value Object를 사용하지 않고 조회결과를 사용자 정의 DTO, Map 등으로 매핑해 사용할 수 있음
* JDBC에 비해 빠른 개발이 가능하고 생산성이 향상됨
