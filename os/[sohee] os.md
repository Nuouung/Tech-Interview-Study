
# ****스레드와 프로세스의 차이****

- 프로세스는 메모리에 올라와 실행 중인 프로그램. OS로부터 시스템 자원을 할당받는 작업의 단위
    - 프로그램 : 작업을 수행하기 위한 명령어들의 모음 (메모리에 올라오지 않은 정적인 상태)
    
    프로세스는 함수의 매개변수, 복귀주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함합니다. 또한 프로세스는 프로세스 실행 중에 동적으로 할장되는 메모리인 힙을 포함합니다. 또한 하나의 프로세스는 하나의 PCB를 갖고 있으며 PCB는 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조 입니다. 운영체제는 프로세스를 관리하기 위해 프로세스 생성시 PCB를 생성하며 프로세스간의 context switching이 발생할 때 진행중인 task의 내용을 PCB에 저장하게 됩니다. 이후에 다시 CPU를 할당받게 되면 PCB에 저장된 내용을 통해 해당 시점부터 task가 다시 시작될 수 있습니다.
    
- 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다.
    - Code : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
    - Data : 전역변수, 정적변수, 배열 등
        - 초기화 된 데이터는 data 영역에 저장
        - 초기화 되지 않은 데이터는 bss 영역에 저장
    - Heap : 동적 할당 시 사용 (new(), malloc() 등)
    - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
- 스레드는 프로세스 안에서 실행 되는 작업 단위이다.
    
    하나의 프로세스 내에서 독립적으로 동작하며 프로세스의 주소 공간이나 자원을 공유할 수 있습니다. 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성되며 같은 프로세스에 속한 스레드들은 데이터 섹션, 전역변수와 같은 운영체제 자원들을 공유합니다. 또한 스레드는 스레드간의 자원의 생성과 관리의 중복성을 최소화하여 독립적인 작업을 수행하기 위해 각자의 스택과 PC 레지스터 값을 갖고 있습니다.
    
- 스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유
- 스택을 스레드마다 독립적으로 할당하는 이유
    
    스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능함을 의미하고 이는 독립적인 실행 흐름이 추가된다는 것이다. 따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당하는 것이다.
    
- PC 레지스터를 스레드마다 독립적으로 할당하는 이유는 뭘까?
    
    PC 값은 스레드가 명령어의 어디까지 수행했는지를 나타내게 된다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다.
    

# 프로세스 제어 블록(Process Control Block, PCB)

- 특정 프로세스에 대한 중요한 정보를 저장하고 있는 커널 내의 자료구조
- PCB가 필요한 이유
    
    CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. (interrupt가 발생해서 할당받은 프로세스가 wating 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때)
    
    이때, 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것이다.
    

# ****멀티스레드와 멀티프로세스 사용시 각각의 장단점****

- 멀티프로세스는 하나의 컴퓨터에 여러 CPU를 장착하여 하나 이상의 프로세스들을 동시에 병렬 처리하는 방식 입니다. 멀티프로세스의 장점으로는 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 주지 않는 안전성 입니다. 하지만 각각 독립된 메모리 영역을 갖고 있어 작업량이 많은 경우 오버헤드가 발생할 수 있으며 Context Switching으로 인한 성능 저하 이슈가 존재합니다.
- 멀티스레드는 하나의 프로세스에서 여러 스레드를 구성해 각각의 스레드가 하나의 작업을 처리하는 방식입니다. 스레드 간의 통신 시 전역 변수 또는 동적으로 할당된 Heap 영역을 사용하여 데이터를 주고 받을 수 있기 때문에 멀티프로세스 방식에 비해 메모리 공간과 시스템 자원 소모가 줄어 들게 됩니다. 하지만 서로 다른 스레드가 데이터를 공유하기 때문에 이미 사용중인 전역 변수에 접근 할 경우 잘못된 값을 읽어오거나 수정할 수 있기에 안정성 이슈가 존재합니다.
- 일반적으로 멀티스레드르 사용하는 이유는 사용자와 상호작용하는 애플리케이션에서 단일 스레드로 Network 또는 DB 와 같은 긴 작업(Long-running task) 을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호작용이 불능인 상태가 될 수 있기 때문이다.
- 멀티프로세스의 context Switching의 경우 프로세스 간의 공유하는 데이터가 없으므로 cache가 쌓아둔 데이터를 초기화하고 새로운 cache 정보를 수집해야 한다. 반면 스레드의 경우 저장된 cache 데이터는 스레드가 변경되어도 공유하는 데이터가 있기 때문에 멀티프로세스에 비해 빠른 context switching이 일어날 수 있다.
- 미디어 플레이어나 메신저와 같은 하나의 프로세스에서 동영상 재생, 음악 재생 또는 채팅, 파일 전송 기능과 같이 두가지 이상의 작업을 처리하기 위해서는 멀티스레드 방식이 효율적이며 여러개의 프로세스가 필요하거나 하나의 프로세스가 root 역할을 해야하는 경우에는 멀티프로세스 방식을 사용하는 것이 효율적입니다.
- 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
    
    프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 더욱 효율적이기 때문이다. 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다. Context Switching시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다.-> 스레드는 Stack 영역만 초기화하면 되기 때문이다.
    
    스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하므로 IPC에 비해 비용이 적고 더 빠르다. -> 스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유하기 때문이다.
    

# **Context Switching**

- 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
- CPU는 한번에 하나의 프로세스만 처리할 수 있는데, 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 프로세스의 상태를 PCB에 저장하고 다음에 진행할 프로세스의 상태값을 읽어 처리하는 과정
- Context Switching은 Cache 초기화, Memory mapping 초기화, 메모리 접근을 위해 커널이 항상 실행되어야 하기 때문에 많은 비용이 소모된다
- Context Switching의 비용은 프로세스가 스레드보다 더 많이 든다.
    
    스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 발생시 Stack 영역만 변경을 진행하면 되기 때문이다.
    
- 다양한 사람들이 동시에 사용하는 것처럼 하기 위해서 Context Switching이 필요하게 되었습니다.
- 수행 과정
    1. Task의 대부분 정보는 Register에 저장되고 PCB(Process Control Block)로 관리된다.
    2. 현재 실행하고 있는 Task의 PCB 정보를 저장한다. (Process Stack, Ready Queue)
    3. 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

# ****Thread-safe****

- 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것을 말한다
- 이를 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 한다.
- 동기화 기법으로는 뮤텍스나 세마포어가 존재

# 동기화

- 한정적인 시스템 자원에 여러 스레드가 동시에 접근해서 사용하면 문제가 발생할 수 있다. 이 문제를 방지하기 위해 여러 스레드에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 기법
- 커널 모드의 동기화
    - 세마포어
        
        현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성
        
    - 뮤텍스
        
        임계 구역을 가진 스레드들의 Running time이 겹치지 않게 각각 단독으로 실행되게 하는 기술
        
    - 모니터
        
        Mutex(Lock)와 Condition Variables를 가지고 있는 Synchronization 매커니즘
        
- 뮤텍스와 모니터의 차이
    
    뮤텍스는 다른 프로세스나 스레드 간에 동기화를 위해 사용하고 모니터는 하나의 프로세스내에서 다른 스레드 간에 동기화할 때 사용한다
    
    뮤텍스는 운영체제 커널에 의해 제공되고 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다
    
- 세마포어와 모니터의 차이
    
    세마포어는 카운터라는 변수값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시 매번 값을 따로 지정해줘야 하는 등 조금 번거롭다. 반면, 모니터는 카운터 값을 0 또는 1으로 주어야 하는 고민을 할 필요가 없이 synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화할 수 있다.
    
- 세마포어와 뮤텍스의 차이
    
    뮤텍스는 동기화 대상이 1개일 때 사용하고 세마포어는 동기화 대상이 여러 개일때 사용한다.
    
    뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있다. 하지만 세마포어는 소유하지 않고 있는 다른 스레드가 세마포어를 해제할 수 있다.
    

# ****임계영역****

- 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부
- 임계 영역에서 동기화를 진행하지 못하면 치명적인 문제가 발생.
- 따라서 임계 구역 문제를 해결하기 위해서는 3가지 필수 조건이 있다.
    1. 상호 배제(Mutual exclusion) : 프로세스 P1이 공유 자원을 접근하는 임계 구역 코드를 수행하고 있으면 다른 프로세스들은 공유 자원을 접근하는 임계 구역 코드를 수행할 수 없다. 즉, 한 순간에 하나의 스레드만이 실행될 수 있다.
    2. 진행(Progress) : 임계 구역에서 실행중인 프로세스가 없고 별도의 동작이 없는 프로세스들만 임계 구역 진입 후보로서 참여될 수 있다.
    3. 한정된 대기(Bounded Waiting) : P1이 임계 구역에 진입 신청 후부터 받아들여질때까지, 다른 프로세스들이 임계 구역에 진입하는 횟수는 제한이 있어야 한다.

# ****프로세스의 주소 공간****

- 프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있다.
    - 코드 Segment : 프로그램 소스 코드 저장
    - 데이터 Segment : 전역 변수 저장
    - 스택 Segment : 함수, 지역 변수 저장
- 이렇게 구역을 나눈 이유는 최대한 데이터를 공유하여 메모리 사용량을 줄여야 하기 때문이다.
    
    Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유함
    
    Stack과 데이터를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것!
    

# ****프로세스의 상태****

1. new(생성) : 프로세스를 생성하고 있는 단계로 커널 공간에 PCB가 만들어진 상태를 말합니다.
2. ready (준비) : 프로세스가 CPU를 기다리는 상태로 프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻을 상태입니다. 즉, CPU를 할당 받으면 바로 실행가능한 상태를 뜻합니다. 이때, ready 상태를 가지는 여러개의 프로세스는 존재할 수 있습니다.
3. Running (실행) : 프로세스가 CPU에 할당되어 실행중인 상태를 말합니다.
4. waiting (대기) : 프로세스가 입출력이나 임계구역 접근과 같은 이벤트를 기다리는 상태를 말합니다.
5. Terminate (종료) : 프로세스의 종료상태를 말합니다.

<전이 상태>

- running -> ready (Timeout): 일정시간이 지나면 스케줄러에 의해 PCB에 저장되고, 프로세스 반납후 준비 상태로 전이됩니다.
- ready -> running (Dispatch): ready 프로세스 중 하나가 cpu 할당을 받아 실행상태로 전이됩니다.
- waiting -> ready (wake up) : 자원할당이 완료되면 ready상태로 전이됩니다.
- running -> waiting (Sleep/ block): I/O 등의 자원을 즉시할당 받기 어려워 할당 받을때까지 기다리는 상태로 전이됩니다.

# 프로세스 스케줄러의 종류

- 스케줄러 : 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드
- 역할과 목적에 따라서 단기, 중기, 장기 스케줄러로 구분할 수 있습니다. 장기 스케줄러는 어떤 프로세스를 준비 큐에 진입시킬지를 결정하는 역할을 수행하는 스케줄러로써 디스크에 존재하는 프로그램에게 메모리를 할당하는 문제에 관여하게 됩니다. 단기 스케줄러는 CPU 스케줄러라고도 하며 준비 큐에 존재하는 프로세스 중에서 어떠한 프로세스에 CPU를 할당할 것인지 결정하는 역할을 수행합니다. 중기 스케줄러는 메모리에 적재된 프로세스의 수를 동적으로 관리하기 위한 스케줄러이다.

# ****각각의 스케줄러에 따라서 프로세스의 상태가 어떻게 변하는지?****

- 장기 스케줄러는 디스크에 존재하는 프로그램 중 어떤 프로그램에게 메모리를 할당할 지를 결정하는데 이 때 장기 스케줄러에 의해 메모리가 할당된 프로세스는 `new` 상태에서 `ready` 상태로 변하게 됩니다.
    
    단기 스케줄러는 어떠한 프로세스에 CPU를 할당할 것인지를 결정하는데 이 때 단기 스케줄러에 의해 CPU가 할당된 프로세스는 `ready` 상태에서 `running` 상태로 변하게 됩니다.
    
    중기 스케줄러는 메모리에 적재된 프로세스의 수를 동적으로 관리하기 위하여 당장에 CPU 할당 가능성이 적은 프로세스들을 선정하여 디스크의 스왑 영역에 저장하는 역할을 수행하는데 이 때 중기 스케줄러에 의해 메모리 할당이 해제된 프로세스들은 각각 `ready` 또는 `blocked` 상태에서 `suspended ready` , `suspended blocked` 상태로 변하게 됩니다.
    

# ****스케줄링은 왜 필요한가요?****

- 스케줄링은 CPU 이용률을 최대화하기 위해서 스케줄링 알고리즘을 이용하여 현재 프로세스가 점유하고 있는 CPU를 다른 프로세스에게 양도하는 것을 의미한다.  프로세스 스케줄링이 필요한 이유는 CPU를 사용하는 패턴이 상이한 여러 프로세스가 동일한 시스템에서 함께 실행되기 때문인데 CPU 버스트가 균일하지 않은 다양한 프로그램이 공존하는 시분할 시스템에서는 스케줄링을 통해 CPU 이용률을 최대화 할 수 있습니다. 만약 스케줄링이 없다면 CPU를 점유한 프로세스가 모든 작업을 끝마칠 때 까지 기다려야 하는데 해당 프로세스가 CPU 버스트가 낮고 IO 버스트가 상대적으로 높은 프로그램이라면 다른 프로세스들은 수행되지 못하고 CPU를 낭비한채로 대기해야 합니다. 이러한 비효율적인 부분을 스케줄링을 통해 개선하여 CPU 이용률을 최대화 하는 것이 스케줄링의 궁극적인 목표입니다.

# ****스케줄링의 성능을 어떠한 기준으로 판단할 수 있나요?****

- 일반적으로 시스템의 관점과 사용자의 관점이라는 두 가지 측면으로 나누어서 생각해볼 수 있습니다.
    
    CPU의 관점에서 스케줄링의 성능을 평가하는 요소로는 CPU활용도와 처리량이 있습니다. CPU의 입장에서는 가능한 CPU의 이용률을 극대화하고 주어진 시간내에 최대한 많은 프로세스를 처리하는 것이 목표이기 때문에 CPU가 휴면상태에 머무르는 시간을 최대한 줄이면서 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것을 목적으로 합니다. 사용자의 관점에서 스케줄링의 성능을 평가하는 요소로는 소요시간, 대기시간, 응답시간을 들 수 있습니다. 먼저 소요시간은 프로세스가 CPU를 요청한 시점부터 CPU를 반납할 때 까지의 시간을 의미하며, 대기 시간은 프로세스가 CPU를 할당받기 위해 준비 큐에서 대기한 시간을 의미합니다. 마지막으로 응답시간은 준비큐에 들어온 다음부터 첫번째 CPU를 획득하기 까지 걸린 시간을 의미합니다 
    
- CPU 이용률과 처리량을 최대화하고 소요시간, 대기시간, 응답시간을 최소화하는 것이 가장 이상적인 스케줄링 기법입니다.

# ****스케줄링 알고리즘****

- Preemptive(선점) vs 1. Non-Preemptive(비선점)
    
    선점은 프로세스가 CPU를 점유하고 있는 동안 I/O나 인터럽트가 발생하지 않았음에도 다른 프로세스가 해당 CPU를 강제로 점유할 수 있다. 비선점은 한 프로세스가 CPU를 점유했다면 I/O나 인터럽트 발생 또는 프로세스가 종료될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다.
    

### **1. FCFS (First Come First Serve)**

- 먼저 도착한 프로세스를 먼저 처리하는 알고리즘입니다. 또한, '비선점형'입니다.
- 응답시간이 길어질 수 있으며 Convey Effect(호위 효과) 즉, 긴 처리시간의 프로세스가 선점되어버리면 나머지 프로세스들은 끝날때 까지 대기해야 합니다. 따라서 평균 대기시간의 편차가 큽니다.

### **2. SJF(Shorted Job First)**

- CPU burst time이 짧은 작업을 우선으로 할당하는 방법입니다.
- 가장 적은 평균 대기 시간을 달성할 수 있습니다.
- 만약 CPU버스트 시간이 동일하다면 FCFS방식을 따릅니다. 다만 선점형인 경우에는 위와같이 진행이 되지만 비 선점형일 경우엔 최소잔여시간우선(SRTF) 법칙을 따릅니다.
- 기아현상이 발생할 가능성이 있습니다.
    - 기아현상

### **3. SRTF (Shortest Remaining Time First)**

- 남은 프로세스의 burst time보다 더 짧은 process가 도착하면 CPU를 빼앗습니다. 또한, 프로세스가 새로 들어올때마다 갱신됩니다.
- 기아현상이 생깁니다.
- 새로운 프로세스가 들어올때마다 스케줄링이 변경되므로 CPU 사용 시간(burst time)을 정확히 예측하기 어렵습니다.

### **4. RR (Round Robin) - 선점**

- 일정 시간을 정하여 하나의 프로세스가 이 시간동안 수행하고 다시 대기 상태로 돌아간다. 그리고 다음 프로세스 역시 같은 시간동안 수행한 후, 대기한다. 이러한 작업을 모든 프로세스가 돌아가면서 진행하며, 마지막 프로세스가 끝나면 다시 처음 프로세스로 돌아와서 작업을 반복한다.
- CPU 사용시간이 랜덤할때 더욱 효율적입니다. 또한, 평균 대기 시간(Average Waiting Time)은 조금 길어질 수 있으나, 응답시간(Response)이 짧아집니다.
- 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가합니다 따라서 공정한 스케줄링이라고 할 수 있습니다.
- 시간 할당량이 작을수록 문맥교환이 자주 일어나서 많은 Overhead가 발생하고 너무 길면 FCFS와 다를바 없어집니다.

### **5. Priority Scheduling**

특징

- 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링입니다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높습니다.
- '선점형' 방식에서는 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점합니다.
- '비선점형' 방식에서는 더 높은 우선순위의 프로세스가 들어오면 Ready queue의 head 부분에 넣습니다.
- 기아현상
- 무한 정지(infinite blocking) : 프로세스가 CPU를 사용할 준비가 되었지만 우선순위가 낮을 경우 무한 대기하는 상태가 되는 것 (Aging 기법으로 큐에 남아있었던 시간으로 가중치를 부여해 문제를 해결할 수 있습니다.)

### **6. MLQ (MultiLevel Queue Scheduling)**

- 우선순위마다 준비 큐를 형성하고 항상 가장 높은 우선순위 큐의 프로세스에 cpu를 할당합니다. (우선순위가 낮은 큐에서 작업 실행 중이더라도 상위 단계의 큐에 프로세스가 도착하면 CPU를 빼앗는 선점형 스케줄링)
- 각 큐는 독자적 스케줄링 사용이 가능하다.
- 큐들 간의 프로세스 이동이 불가하기 때문에 스케줄링 부담이 적지만 유연성이 떨어집니다.
- 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 기다리는 기아 현상이 발생할 수도 있습니다.

### **7. MLFQ (MultiLevel Feedback Queue Scheduling)**

특징

- 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 CPU를 할당받아 실행됩니다. 해당 큐의 CPU 시간 할당량(Time Quantum)이 끝나면 한 단계 아래의 준비 큐에 들어갑니다.
- 우선순위가 높은 단계의 큐일수록 시간 할당량(Time Quantum)이 작습니다.
- 큐 사이의 프로세스 이동 가능하며 CPU Burst는 낮은 우선순위의 큐, I/O Burst는 높은 우선순위의 큐에 배치합니다.
- 가장 우선순위가 낮은 큐는 FCFS 스케줄링입니다. 나머지는 RR 스케줄링 기법을 사용합니다.
- 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동합니다 (에이징 기법을 통한 기아상태 예방가능합니다.)

고려사항

- 큐(Queue)의 수.
- 각 큐에 대한 스케줄링 알고리즘.
- 작업을 좀 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법.
- 작업을 좀 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법.
- 프로세스들이 어느 큐에 들어갈 것인가를 결정하는 방법.
- 프로세스가 서비스를 받는 시기를 결정하는 방법.

### **MLQ VS MLFQ**

- MLQ는 큐와 큐 사이에 프로세스들이 이동할 수 없지만 MLFQ는 이동 가능합니다.
- MLQ가 MLFQ보다 스케줄링 부담이 적지만 유연성은 떨어집니다.
- MLQ는 기아현상이 발생할 수 있지만 MFQ는 에이징 기법을 통해 기아현상을 예방 가능합니다.

# ****스케줄링의 목표****

- 스케줄링의 보편적인 목표는 CPU를 잘 사용하기 위해 프로세스를 잘 배정하는 것입니다. 특정 시스템에 따라서 추구하는 목표가 달라질 수 있습니다. batch에서는 시간보다는 처리량이 중요하고 interactive에서는 응답시간이 빠르고 대기 시간이 적을 수록 좋고 realtime에서는 정해진 시간 제약 조건을 만족시키는 것이 스케줄링의 목표입니다.

# 페이지 교체 알고리즘

- 메모리가 가득차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고 해당 공간에 현재 필요한 페이지를 in 시켜야 한다. 이때, 어떤 페이지를 out 시킬지 정해야 한다
    1. FIFO(First in First out) 알고리즘 : 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
    2. 최적 페이지 교체 알고리즘(Optimal Page Replacement) : • 앞으로 가장 오랫동안 사용하지 않은 페이지를 교체하는 방법
    3. LRU 알고리즘(Least Recently Used) : 최근에 사용하지 않은 페이지를 가장 먼저 내보내는 방법
    4. LFU 알고리즘(Least Frequently Used) : 페이지의 참조 횟수로 교체할 페이지를 결정
    5. 클럭 알고리즘(NRU : Not Recently Used, NUR : Not Used Recently) : LRU를 근사시킨 알고리즘이라고 하며, 오랫동안 사용하지 않은 페이지 중 하나를 교체

# 단편화

- 외부 단편화 : 프로그램의 크기보다 분할의 크기가 작은 경우, 해당 분할이 비어있음에도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간
- 내부 단편화 : 프로그램의 크기보다 분할의 크기가 큰 경우, 해당 분할에 프로그램을 적재하고 남는 메모리 공간

# ****인터럽트(Interrupt)****

- 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것

# ****System Call****

- 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해주는 것
- 시스템 콜은 왜 필요할까?
    
    우리가 일반적으로 사용하는 프로그램은 응용 프로그램 이다. 유저레벨의 프로그램은 유저레벨의 함수들만으로는 많은 기능을 구현하기 힘들기 때문에, 커널의 도움을 받아야만 한다.
    
    커널에 관련한 것들은 커널모드로 전환하여 해당 작업을 수행해야한다. 이러한 커널 모드로 통한 작업을 할때의 전환을 시스템 콜이라고 한다.
    
- fork( ), exec( ), wait( )와 같은 것들은 Process 생성과 제어를 위한 System call임.
    - fork, exec는 새로운 Process 생성과 관련이 되어 있다.
    - wait는 Process (Parent)가 만든 다른 Process(child) 가 끝날 때까지 기다리는 명령어임.

# ****데드락(교착 상태)****

- 첫 번째 스레드는 두 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고, 두 번째 스레드 역시 첫 번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리는 상황을 일컷는다. 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이를 교착상태에 빠졌다고 한다.
- 한정된 자원을 여러 곳에서 사용하려고 할 때, 발생하는 문제
- 프로세스가 다음 처리를 위한 자원을 얻지 못해서 무한정 대기하는 상태
- 데드락 발생조건 (4가지 모두 성립해야 발생)
    1. 상호배제 (Mutual exclusion) : 자원은 한번에 한 프로세스만 사용 가능하다.
    2. 점유대기 (Hold and Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야한다.
    3. 순환대기 (Circular wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다. 
    4. 비선점 (No Preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 뺏을 수 없다.
- 데드락 해결방안
    1. 예방 (prevention) : 교착 상태 발생 조건 중 하나를 제거하면서 해결하는 방법으로 자원낭비가 심합니다.
        - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
        - 점유대기 부정 : 프로세스 실행 전 필요한 모든 자원을 할당
        - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구 따라서 프로세스의 속도를 떨어뜨리고 자원의 접근을 불필요하게 거부
        - 비선점 부정 : 한 프로세스에서 다른 프로세스가 점유한 자원을 원하면, 다른 프로세스가 점유한 자원을 강제적으로 반납시키고 그것을 원하는 프로세스에게 할당
    2. 회피(avoidance) : 데드락을 발생시킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복하는 방법. 대표적으로 은행원 알고리즘이 있습니다.
        - 은행원 알고리즘
            
            프로세스가 자원을 요구할때 자원을 할당한 후에도 안정 상태이면 자원을 할당하고, 그렇지 않으면 다른 자원이 해제될때까지 대기했다가 자원을 할당합니다.
            
            이러한 알고리즘의 단점으로는 할당할 수 있는 자원의 수가 일정해야 하며 항상 불안전 상태를 방지해야 하므로 자원의 이용도가 낮아지게 됩니다. 
            
    3. 탐지(Detection) : 자원 할당 그래프를 통해서 교착상태를 탐지하고, 자원요청시 탐지 알고리즘을 실행시켜 오버헤드를 발생합니다.
    4. 회복(Recovery) : 교착상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복하는 방법입니다. 프로세스 종료 방법으로는 교착상태의 프로세스를 모두 중지하거나, 교착상태가 제거될때까지 하나씩 프로세스를 중지하는 방법이 있습니다. 자원 선점 방법으로는 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 해당 프로세스는 정지시키고 다른 프로세스에게 할당하거나 우선순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점을 하는 방법이 있습니다.
- 데드락이 발생했는지 어떻게 알 수 있는가?
    - 데드락의 유무를 확인하기 위해서는 자원 할당 그래프라는 프로세스들과 자원들 사이의 관계를 도식화한 그래프를 활용할 수 있는데 이 때 그래프에서 사이클이 존재하는지 여부에 따라서 데드락이 발생하는지 여부를 확인할 수 있습니다. 먼저 그래프에 사이클이 존재하지 않는다면 데드락이 존재하지 않다고 판단할 수 있지만 그래프에 사이클이 존재한다고 해서 반드시 데드락이 존재하는 것은 아니며 데드락이 존재할 가능성을 가지고 있다는 것으로 해석할 수 있습니다. 그래프에서의 사이클은 말 그대로 가능성만을 의미하기 때문에 해당 사이클에서 데드락이 발생하는지 여부를 따져보아야 합니다. 만약 그래프에 사이클이 존재하면서 사이클을 이루는 자원들의 인스턴스가 하나만 존재하는 경우라면 데드락을 발생시키지 않고 문제를 해결할 수 있는 방법이 존재하지 않기 때문에 데드락이 발생한다고 판단할 수 있습니다.

# 경쟁 상태 ****Race Condition****

- 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태
- 발생하는 경우
    1. 커널 작업을 수행하는 중에 인터럽트 발생
        
        ◦ 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
        
        ◦ 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.
        
    2. 프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때
        
         ◦ 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 
        
         ◦ 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
        
    3. 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때
        
         ◦ 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
        
         ◦ 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법
        
- 경쟁상태를 방지하기 위한 해결법의 충족 조건
    - Mutual Exclusion (상호 배제)
        - 어떤 프로세스 가 임계 영역을 수행 중이면 다른 모든 프로세스들은 그 임계 영역에 들어가면 안된다.
    - Progress
        - 아무도 임계 영역에 있지 않은 상태에서 임계 영역에 들어가려는 프로세스가 있으면 들어가게 해주어야 한다. ( livelock 방지 )
    - Bounded Waiting
        - 프로세스가 임계 영역에 들어가려고 요청한 후부터 다른 프로세스들이 임계 영역에 들어가는 횟수에 한계가 있어야 한다 ( starvation 방지 )

# 운영체제

- 시스템의 자원과 동작을 관리하는 소프트웨어
- 컴퓨터 시스템의 하드웨어적인 자원과 소프트웨어적인 자원을 효율적으로 관리함으로써 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어
- 프로세스 관리 / 저장장치 관리 / 네트워킹 / 게정 관리 / 디바이스 드라이버
- 운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다
- 커널 (Kernel) : 주 메모리에 상주하는 운영체제 핵심

# ****운영체제 핵심 기능****

1. 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리한다.
2. 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공한다.
3. 사용자와 시스템간의 편리한 인터페이스를 제공한다.
4. 시스템의 각종 하드웨어와 네트워크를 관리, 제어한다.
5. 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공한다.
6. 시스템의 오류를 검사하고 복구한다.
7. 자원 보호 기능을 제공한다.
8. 입 출력에 대한 보조 기능을 제공한다.
9. 가상 계산기 능력을 제공한다.

# ****Paging vs Segmentation****

- 가상 메모리를 관리하는 기법
- 가상 메모리는 실행중인 프로세스가 가상의 공간을 참조하여 마치 커다란 물리 메모리를 갖고 있는 것처럼 사용할 수 있도록 하는 것이다.
- 페이징 : 프로세스를 동일한 크기의 페이지로 나누어 물리적 메모리에 불연속적으로 저장하는 방식으로 외부 단편화와 압축 작업을 해소하기 위함이다. 내부 단편화 발생
- 세그먼트 : 프로세스를 서로 크기가 다른 논리적인 블록 단위인 '세그먼트(Segment)'로 분할하고 메모리에 배치하는 것을 말하며, 외부 단편화가 발생할 수 있다

# 동기 vs 비동기 vs 블로킹 vs 넌블로킹

- 동기 방식은 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 아무것도 못하고 대기해야 한다. 비동기 방식은 어떤 작업을 요청했을 때 그 작업이 종료될 때까지 다른 작업을 할 수 있어 자원을 효율적으로 사용할 수 있다
- 블로킹/논블로킹은 내가 직접 제어할 수 없는 대상(IO/멀티스레드)을 상대하는 방법에 대한 분류
    
    블로킹 방식은 대상의 작업이 끝날 때 까지 제어권을 대상이 가지고 있는 것을 의미합니다. 반면에 논블로킹은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행합니다.
    

# ****IPC(Inter Process Communication)****

- 독립적인 공간을 가진 프로세스간 통신에 사용되는 기법이 IPC 통신이다. 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.
