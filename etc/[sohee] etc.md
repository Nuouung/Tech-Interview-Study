# 도커

- 프로세스를 격리하고, 프로세스에 필요한 컴퓨팅 자원을 독립적으로 할당/격리하여 완벽히 격리된 가상 환경을 구축
- 호스트 OS의 격리된 공간에서 프로세스가 동작할 수 있게 하는 가상화 기술
    - 가상화 : 하나의 물리적 리소스 위에서 여러 OS를 동시에 실행할 수 있도록 함
- 가상머신 VS 도커 컨테이너
    - 가상 머신 : 호스트 OS에서 여러 운영체제를 생성해 사용한다. 각각이 독립된 시스템 자원을 할당 받아야 하기 때문에 용량이 많이 든다
    - 도커 컨테이너 : 컨테이너에 필요한 커널은 호스트의 커널과 공유해서 사용한다
- 도커 이미지 : 컨테이너를 생성할 때 필요한 파일, 설정값 등을 포함하고 있다
- 도커 컨테이너 : 도커 이미지로부터 생성된 격리된 프로세스
- 도커 컴포즈 : 여러 커테이너를 하나의 파일에서 관리한다
- 도커 파일 : 도커 이미지를 만들기 위한 설정 파일
- 장점
    - 쉽고 빠르게 실행 환경 구축 가능 → 개발서버/운영서버를 똑같은 환경으로 구축하고 복사할 수 있다
    - 컨테이너끼리 분리되어 있기 때문에 보안상 이점이 있다
- 단점
    - 플랫폼 의존적이다 → 리눅스에서만 실행 가능하다

# CI/CD

- 개발~배포 단계를 자동화해서 서비스를 짧은 주기로 배포할 수 있는 방법
- CI : 빌드/테스트를 자동화 해 Repository에 머지한다
- CD : CI를 통해서 배포될 준비가 끝난 애플리케이션을 개발자가 수동으로, 혹은 자동으로 배포를 진행하는 것.

# 테스트 코드

- 단위 테스트 : 소스코드의 특정 메서드가 의도한대로 작동하는지 검증
- 통합 테스트 : 서로 다른 시스템들의 상호작용이 제대로 이루어지는지 검증
- 좋은 테스트 코드란 ?
    - 1개의 테스트 함수에 대해서는 assert를 최소화해야한다.
    - 1개의 테스트 함수에는 1가지 개념만을 테스트하여야 한다.

## JUnit

- java의 단위테스트를 위한 프레임워크
- 사용 이유
    - 내가 개발한 프로덕션 코드가 의도한대로 잘 동작하는지 확인하기 위해 사용
    - 리팩토링을 안심하고 할 수 있다
    - 빠르게 코드의 동작 결과를 확인할 수 있다
- mocking하는 이유
    - 의존성 있는 코드를 테스트 하다가 테스트를 실패할 경우 어떤 코드가 문제인지 모른다.
        
        그래서 코드가 의존하고 있는 객체를 가짜로 만들어 의존성을 제거해 테스트 중인 코드에만 집중할 수 있다  
        
- 개념
    - mock : 실제 객체를 상속 받아 mock 객체를 만듦. 실제로 메서드는 갖고 있지만 내부 구현이 없는 상태
    - stub : mock객체에 어떤 결과를 반환하라고 정해진 결과값을 준비하는데 이것을 stub이라고 함
    - spy : stub 하지 않은 메소드들은 원본 메소드 그대로 사용
    - assertThat : 첫번째 파라미터에는 비교대상 값을, 두번째 파라미터로는 비교로직이 담긴 Matcher가 사용된다.
- 어노테이션
    - @Mock : 실제 객체를 상속 받아 mock 객체를 만듦. 실제로 메서드는 갖고 있지만 내부 구현이 없는 상태
    - @Spy : stub 하지 않은 메소드들은 원본 메소드 그대로 사용
    - @InjectMocks : @Spy, @Mock 어노테이션이 붙은 객체들을 주입

# Message Queue

- 메시지를 이용해 중간에서 여러 서비스들을 연결해주는 역할을 한다.
- 기존의 동기식 통신 방식은 사용자로부터 받은 요청을 전부 처리할 때까지 Blocking 상태에 빠지게 된다.
    
    요청이 전부 처리되어야 사용자에게 응답을 주고 다시 요청을 받을 수 있다.
    
- 장점
    - 큐에 넣기 때문에 나중에 처리할 수 있다 = 비동기
    - 애플리케이션과 분리할 수 있다
    - 실패시 재실행이 가능하다

# JWT

- Json을 이용하여 사용자 정보를 저장하는 Token
- Header, Payload, Signature 3파트 나뉘어있다.
Header에는 토큰의 타입과 Signature를 해싱하기 위한 알고리즘 방식을 지정하고
Payload는 토큰에서 사용할 정보의 조각들인 Claim이 담겨 있다.
Signature는 유효성 검증을 할 때 사용한다. 헤더와 페이로드의 값을 각각 base64로 인코딩하고 그 값을 비밀키를 이용해 헤더에서 정의한 알고리즘으로 해싱을 하고 이 값을 다시 base 64로 인코딩해서 생성한다.
