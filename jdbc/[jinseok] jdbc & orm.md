### 영속성(Persistance)

* 데이터를 생성한 프로세스가 종료되더라도 정보가 사라지지 않는 '데이터'의 특성
* 메모리에 데이터를 저장하게 될 경우, 프로세스 종료 시 데이터는 모두 사라짐 (프로세스 종료 시 heap, stack, code, data 모두 사라짐)
* 데이터를 데이터베이스에 저장할 경우 프로세스가 종료되더라도 데이터가 유실되지 않음
* 데이터를 데이터베이스 혹은 파일에 저장하는 행위 = 데이터에 영속성을 부여하는 행위

### 영속성 레이어(Persistence Layer)

* 프로그램 아키텍처 수준에서, 데이터에 영속성을 부여하는 계층
* 아키텍처적인 관점에서 보면 Business logic과 데이터베이스 사이에 존재한다
* 자바에서는 JDBC를 통해 직접 구현이 가능하지만 일반적으로 '마이바티스', 'JPA'와 같은 영속성 프레임워크를 통해 개발이 이루어진다.

### 영속성 프레임워크(Persistence Framework)

* JDBC를 직접 구현하는 복잡함이나 번거로움 없이 간단하게 데이터베이스와 연동되는 시스템을 개발하기 위한 프레임워크를 의미
* SQL 문장으로 직접 데이터베이스의 데이터를 다루는 'SQL Mapper'와 객체를 통해 간접적으로 데이터베이스의 데이터를 다루는 'ORM'이 존재
* SQL Mapper의 대표적 예 - Mybatis
* ORM의 대표적 예 - JPA, Hibernate

### ORM 

* 객체(Object)와 관계형 데이터베이스(RDB: Relational DB)을 연결(Mapping)하는 것을 말함
* 객체와 관계형 데이터베이스를 ORM이 자동으로 연결해주기 때문에 객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스대로 설계할 수 있다.
* ORM은 내부적으로 JDBC를 사용해서 적절한 SQL을 자동으로 생성하는 식으로 동작
* (but ORM은 완벽하지 않아서 아주 복잡한 SQL은 사람이 직접 짜야한다.)

### ORM의 장점

* SQL문이 아닌 메소드를 통한 DB 조작이 가능 -> 개발자는 비지니스 로직을 구성하는데 집중할 수 있음
* 객체지향적인 코드 작성이 가능 -> 생산성이 증가할 수 있음
* 매핑하는 정보가 class로 명시되기 때문에 유지보수 및 리펙토링에 유리함 

### ORM의 단점

* 프로젝트의 규모가 크고 복잡해 설계가 잘못될 경우 속도 저하 및 일관성을 무너뜨리는 결과를 낳을 수 있음
* 복잡하고 무거운 쿼리는 ORM으로 구현하기 어려운 경우가 있기 때문에 결국 SQL문을 작성해야 할 수도 있음
* 러닝커브(학습곡선)이 높음 (배우기 어려움)

### JPA란

* 자바 진영에서 ORM 표준 기술로 사용되는 인터페이스의 모음
* 인터페이스의 모음이기 때문에 특정 구현체를 칭하는 말은 아님
* JPA를 구현한 대표적인 오픈소스가 Hibernate.
* JPA를 구현한 오픈소스 -> Hibernate, EclipseLink, DataNucleus ...
* 스프링을 사용할 경우, JPA를 한 단계 더 추상화시킨 Spring Data JPA를 사용할 수 있는데 많은 CRUD SQL을 자동으로 처리하기 때문에 개발 생산성에서 매우 유리할 수 있음

### Persistance Context(영속성 컨텍스트)

* 엔티티를 영구 저장하는 환경이라는 뜻
* 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 '가상의 데이터베이스'
* 영속성 컨텍스트는 Entity Manager에 의해 관리됨
* 영속성 컨텍스트는 눈에 보이지 않는 '논리적인 개념.' 실제로 애플리케이션 내에 또 하나의 데이터베이스가 생성되는 것이 아니다. (위에서 설명했듯 가상의 데이터베이스라고 생각하면 됨)
* JPA의 경우 영속성 컨텍스트는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 기능을 제공함

#### 1차 캐시

* 영속성 컨텍스트 내부에 존재하는 캐시(Map). 
* 영속 상태의 모든 엔티티는 1차 캐시 내에 저장됨 
* 영속성 컨텍스트에 의한 transaction이 지속될 경우 애플리케이션은 데이터를 데이터베이스가 아닌 1차 캐시에서 가져옴
* 객체의 동일성을 보장함
* 1차 캐시의 key: @Id로 매핑한 식별자
* 1차 캐시의 value: 엔티티

#### 쓰기 지연

* 엔티티가 영속성 컨텍스트 내에 저장될 때, 해당 엔티티가 바로 데이터베이스에 반영되지 않고 영속성 컨텍스트의 트랜잭션이 종료되는 시점에 query가 전송되는 것
* 영속성 컨텍스트 내에는 '쓰기 지연 SQL 저장소'가 존재 -> 트랜잭션이 종료되지 않으면 모든 쿼리를 쓰기 지연 SQL 저장소에 저장함 -> 트랜잭션이 종료될 때 쿼리를 전송

#### 변경 감지(dirty checking)

* 한 트랜잭션 내에서 발생하는 엔티티의 변경 사항을 감지하고 자동으로 update 해주는 것
* 영속성 컨텍스트의 1차 캐시 덕분에 가능한 기능으로, 1차 캐시에는 엔티티가 적재되는 순간을 기록하는 '스냅샷' 공간이 있음
* 트랜잭션이 종료되고 데이터베이스로 쿼리가 전송될 때 영속성 컨텍스트는 최초의 엔티티(스냅샷)과 트랜잭션이 종료될 때의 엔티티를 비교해 변경 사항이 있으면 변경 정보를 update 쿼리로 만들어 전송함

#### 지연 로딩

* JPA는 엔티티가 실제로 사용되기 전까지 데이터베이스 조회를 지연함
* 즉, 실제 엔티티가 사용될 때 데이터베이스에서 필요한 데이터를 가지고 오는 것
* 이를 위해 내부적으로 프록시 객체가 사용되는데 프록시 객체는 객체의 정보가 담겨 있지 않은 껍데기 객체라고 생각하면 된다.

### 엔티티의 생명주기

* 비영속(new/transient): 영속성 컨텍스트와 전혀 관계 없는 상태(영속성 컨텍스트 외부에 존재)
* 영속(managed): 영속성 컨텍스트에 저장된 상태 (비영속 상태에서 persist() 메소드를 호출해 영속화할 수 있다)
* 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태 <- 영속성 컨텍스트가 제공하는 어떠한 기능도 보장받을 수 없다!
* 삭제(removed): 삭제된 상태

### Mybatis란?

* 객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 쉽게 할 수 있도록 도와주는 개발 프레임워크
* JDBC를 통한 데이터베이스 접근을 캡슐화함
* 일반 SQL 쿼리문, 저장 프로시저 및 고급매핑을 지원
* 애플리케이션 내에 있는 SQL 쿼리문을 별도의 xml 파일로 분리할 수 있어 코드와 SQL을 분리할 수 있는 장점이 있음

### Mybatis의 특징

* 복잡한 쿼리나 다이나믹한 쿼리에 강함. <-> JPA의 경우 내부적으로 쿼리가 자동으로 만들어지기 때문에 복잡한 쿼리에 대응하기 어려움
* 애플리케이션의 비지니스 로직과 SQL 쿼리문이 분리되기 때문에 코드의 간결성 및 유지보수성이 향상됨
* resultType, resultClass 등 Value Object를 사용하지 않고 조회결과를 사용자 정의 DTO, Map 등으로 매핑해 사용할 수 있음
* JDBC에 비해 빠른 개발이 가능하고 생산성이 향상됨
