# ****String, StringBuffer, StringBuilder의 차이****

- JAVA에는 문자열 클래스로 String, StringBuffer, StringBuilder 3가지가 있습니다

## String

- String은 Heap or Constant String Pool에 저장되고 Immutable(불변성) 특징을 갖고 있다.
- literal로 생성된 객체는 string constant pool에 저장된다. pool 내에 같은 문자열이 있다면 해당 주소를 할당한다.
    - String constant pool - Heap 영역에서 String 객체를 위해 별도로 관리하는 장소
- 생성 방식
    - new
    - literal
    
    new 연산자로 생성하면 Heap에 각각 존재하게 되고 리터럴을 이용하면 string constant pool  영역에 존재 
    
- String을 리터럴로 선언할 경우, 내부적으로 String의 intern()이라는 메소드가 호출되게 된다. intern()메서드는 주어진 문자열이 String Constant Pool에 존재하는지 검색하고 있다면 그 주소값을 반환하고 없다면 String Constant Pool에 넣고 새로운 주소값을 반환하게 된다.
- intern() 메서드 : new를 통해 생성된 String객체라 하더라도 string constant pool 내부에 있는 문자열을 검색해 해당 주소값을 반환
- Thread-Safe : Immutable(불변)하기 때문에 멀티쓰레드 환경에서 동기화를 신경 쓸 필요가 없습니다
- 문자열 연산('+', concat 등)을 많이 일어나는 경우, 더이상 참조되지 않는 기존 객체는 Garbage Collection(이하, GC)에 의해 제거되야하기 때문에 성능이 좋지 않습니다. 또한, 문자열 연산이 많아질 때 연산 내부적으로 char 배열을 사용하고, 계속해서 객체를 만드는 오버헤드가 발생하므로 성능이 떨어질 수 밖에 없습니다.
- 문자열 연산시 새로운 String 객체를 생성한다. 이로 인해 메모리 공간의 낭비가 발생하고 성능이 떨어진다. 따라서 문자열 연산이 적고, 조회가 많은 상황에서 쓰기 좋다.

## ****StringBuffer와 StringBuilder****

- Heap에 저장된다
- StringBuffer와 StringBuilder는 mutable한 특성을 갖는다.
- StringBuffer는 동기식이고 StringBuilder는 비동기식이다.
- 단순히 속도적인 측면만 봤을 때는 StringBuilder가 다소 빠르다.
- 초기 생성할 때 Buffer Size를 설정할 수 있는데 이에 의한 생성, 확장 오버로드가 생길 수 있기 때문에 Buffer Size를 잘못 지정할 경우 성능이 떨어질 수도 있다.
- 문자열 연산이 자주 있을 때 사용하면 성능이 좋습니다.
- StringBuffer와 StringBuilder 클래스가 제공하는 메서드는 서로 동일하다. 하지만 동기화 방식에 차이가 있기 때문에 Multi-Thread 환경이라면 값 동기화 보장을 위해 StringBuffer를 사용하고, Single-Thread 환경이라면 StringBuilder를 사용

# ****HashMap과 HashTable****

- Map 인터페이스를 상속받고 Key-Value 구조를 갖는다.
- Hashtable은 동기화를 지원하고 HashMap은 동기화를 지원하지 않는다.
    
    즉, **멀티 스레드 환경에서는 Hashtable**을 사용해야 한다. HashMap을 동기화 하려면 ConcurrentHashMap을 사용하면 된다.
    
- HashMap이 다소 속도가 빠르다. Hashtable은 동기화 처리 비용이 있기 때문이다.
- HashMap은 저장된 요소들의 순회를 위해 Iterator를 반환한다. Hashtable은 Enumeration을 반환한다.

# final

### **Final variable**

- 변수의 값을 **상수**로 지정해서 값을 변경할 수 없음

### **Final method**

- **오버라이딩 불가**
- 예를 들어 부모 클래스에서 speak() 메소드가 입으로 말하도록 정의했는데 자식 클래스에서 재정의하여 손으로 말하도록 기능을 바꿀 수 없게

### **Final class**

- 다른 클래스가 **상속 불가**
- 클래스 내부의 메소드도 오버라이딩 불가
- 대표적으로 String class
- 중요한 어떤 class에 대해 sub class로 시스템이 파괴될 수 있기 때문에 자바에서는 핵심 class에 대해 final class로 선언하고 있다.

# 인스턴스(non-static) 변수****와**** 클래스 (static) 변수****의 차이****

- 인스턴스(non-static) 변수
    - 해당 멤버는 객체마다 별도로 존재하며 인스턴스 멤버라고 부른다. 객체간 공유되지 않는다
    - 객체가 생성될 때, 멤버가 생성되므로 객체 생성 후에 멤버 사용이 가능하고 객체가 사라지면 해당 멤버도 사라진다.
    - 각 인스턴스마다 고유의 값을 가져야 할 때 사용
    - 힙 영역에 올라간다
- 클래스 (static) 변수
    - 클래스 로딩 시에 멤버가 생성된다. 클래스 변수라고도 한다
    - 객체가 생성되기 전에 이미 생성되므로 객체를 생성하지 않고도 사용 가능. 객체가 사라져도 해당 멤버가 사라지지 않는다. 해당 멤버는 프로그램이 종료될 때, 사라진다.
    - 동일한 클래스의 모든 객체들에 의해 공유된다. (하나의 클래스로부터 생성된 여러 객체가 공유한다.)
    - 메소드 영역에 올라간다
    - ermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있다

# ****Interface와 abstract의 차이****

- 추상 클래스를 부분적으로만 완성된 미완성 설계도라고 한다면 인터페이스는 구현된 것이 아무것도 없는 기본 설계도

## ****Interface****

- 구현 객체가 같은 동작을 한다는 것을 보장하기 위해, 인터페ㄴ이스를 구현하는 모든 클래스에 특정한 메소드가 반드시 존재하도록 강제
- 일종의 추상클래스이다. 오직 **추상메소드와 상수만**을 멤버로 가질 수 있다.
- 인터페이스를 쓰는 이유
    - 완벽한 추상화를 이루기 위해(메소드 구현 목적) / 다중 구현 다형성
- 모든 멤버 변수는 public static final 이어야 하며, 생략 가능.
- 모든 메소드는 public abstract 이어야 하며, 생략 가능.
- Java 8부터 default 메소드가 추가되었다. default 키워드가 붙은 메소드는 구현할 수 있으며(일반 메소드처럼), 자식 클래스에서는 이를 오버라이딩할 수 있다. 인터페이스가 변경되면 이를 구현하는 모든 클래스들이 해당 메소드를 다시 구현해야하는 번거로운 문제가 있었다. 이런 문제를 해결하기 위하여 인터페이스에 메소드를 구현할 수 있도록 변경되었다.
- Java 8부터 static 메소드가 추가되었다. 이를 통해 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있게 되었다.

## ****Abstract****

- 추상 메소드 ********
    - 메소드의 정의만 되어있는 비어있는 메소드
    - 사용하는 목적은 추상 메소드를 포함한 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 강제하기 위함이다.
- 추상 클래스
    - 추상 메소드를 하나라도 포함하고 있는 클래스는 추상 클래스가 된다.
    - 추상 메소드를 포함하고 있으므로 인스턴스를 생성할 수 없다
    - 멤버 변수와 구현된 메소드가 존재 가능
    - 공통된 부분을 추상화하여 상속하는 클래스에게 구현을 강제화한다. 메소드의 동작은 구현하는 자식 클래스에게 위임한다.
    - 상속을 받아 기능을 확장시키는 데 목적이 있다.
    - 다중 상속 불가

# OOP

- 프로그래밍에서 필요한 데이터를 추상화시켜서 상태(변수)와 행위(메소드)를 가진 객체를 만들고 **이 객체들간의 유기적인 상호작용으로 로직을 구성**하는 프로그래밍 방법
- 장점
    - 코드의 재사용 용이 / 유지보수가 쉬움 / 대형 프로젝트에 적합(모듈화)
- 단점
    - 처리속도가 상대적으로 느림 / 객체가 많으면 용량이 커질 수 있음 / 설계시 많은 시간과 노력이 필요
- 특징
    
    ### **1. 추상화**
    
    - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    - 클래스를 정의하는 것
    
    ### **2. 캡슐화**
    
    - 관련있는 변수와 메소드를 묶어주는 것
    - (JAVA)접근 제어 지시자를 통해 외부 접근을 제한하며 이를 정보은닉이라고 함
    
    ### **3. 상속**
    
    - 자식클래스는 상속을 통해 부모클래스의 속성과 기능을 물려받음
    - 상속받은 기능의 일부를 수정하여 사용 가능
    
    ### **4. 다형성**
    
    - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석되는 것
    - 오버로딩, 오버라이딩 개념
    - **오버로딩**
        - 같은 클래스 내에서 동일한 이름의 함수를 여러 개 정의하고 매개 변수의 타입과 개수를 다르게 하는 것. 반환 타입은 같아도 상관없음
        - 정적 바인딩된다.
    - **오버라이딩**
        - 상위 클래스 혹은 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다.
        - 동적 바인딩된다.

# ****객체지향 5대원칙(SOLID)****

- 객체지향을 설계할때 지키면 좋은 원칙

### **Single Responsiblity Principle (SRP, 단일 책임 원칙)**

- 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임(기능)만을 가져야 한다.
- 응집도는 높고 결합도는 낮게

### **Open-Closed Principle (OCP, 개방-패쇄 원칙)**

- 객체는 **확장**에 대해서는 **개방적**이고 **수정**에 대해서는 **폐쇄적**이어야 한다는 원칙이다.
- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다.
- 대표적인 문법이 인터페이스(Interface)이다.

### **Liskov Substitution Principle (LSP, 리스코프 치환 원칙)**

- **자식 클래스**는 언제나 자신의 **부모 클래스**를 **대체**할 수 있다는 원칙이다.
- 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다.

### **Interface Segregation Principle (ISP, 인터페이스 분리 원칙)**

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.

### **Dependency Inversion Principle (DIP, 의존 역전 원칙)**

- 상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙이다
- 추상화 된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
- 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미한다.
- DIP를 만족하면 '의존성 주입(DI)' 기술로 변화에 유연한 설계를 할 수 있다.

# ****접근 제한자 (Access Modifier)****

- public
    - 어떤 클래스에서도 접근이 가능하다.
- protected
    - protected 멤버를 포함하는 클래스가 정의되어 있는 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
- private
    - 해당 멤버를 선언한 클래스 내부에서만 접근 가능
- default
    - 아무것도 선언하지 않았을 때 기본
    - 같은 클래스의 멤버와 같은 패키지에서 접근 가능

# ****Collection****

- 다수의 Data 를 다루는데 표준화된 클래스들을 제공해주기 때문에 DataStructure 를 직접 구현하지 않고 편하게 사용할 수 있다
- 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있다.
- List
List 인터페이스를 직접 @Override를 통해 사용자가 정의하여 사용할 수도 있으며, 대표적인 구현체로는 ArrayList가 존재한다. 이는 기존에 있었던 Vector를 개선한 것이다. 이외에도 LinkedList 등의 구현체가 있다.
- Map
대표적인 구현체로 HashMap이 존재한다. key-value 의 구조로 이루어져 있으며 Map 에 대한 구체적인 내용은 DataStructure 부분의 hashtable 과 일치한다. key 를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않는다. key 에 대해서 순서를 보장하기 위해서는 LinkedHashMap을 사용한다.
- Set
대표적인 구현체로 HashSet이 존재한다. value에 대해서 중복된 값을 저장하지 않는다. 사실 Set 자료구조는 Map 의 key-value 구조에서 key 대신에 value 가 들어가 value 를 key 로 하는 자료구조일 뿐이다. 마찬가지로 순서를 보장하지 않으며 순서를 보장해주기 위해서는 LinkedHashSet을 사용한다.
- Stack 과 Queue
Stack 객체는 직접 new 키워드로 사용할 수 있으며, Queue 인터페이스는 JDK 1.5 부터 LinkedList에 new 키워드를 적용하여 사용할 수 있다.

# ****Annotation****

- 어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법이다. 주석과는 그 역할이 다르지만 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다. 또 해석되는 시점을 정할 수도 있다.(Retention Policy)
- 종류
    - built-in annotation : JDK 에 내장되어 있는 어노테이션 ex) @Override
    - Meta annotation : 어노테이션에 대한 정보를 나타내기 위한 어노테이션
    - Custom Annotation : 그리고 개발자가 직접 만들어 내는 어노테이션

# ****Generic****

- 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다.

# ****Multi-Thread 환경에서의 개발****

- Field member
    - 객체가 여러 스레드가 접근하는 싱글톤 객체라면 field 에서 상태값을 갖고 있으면 안된다. 모든 변수를 parameter 로 넘겨받고 return 하는 방식으로 코드를 구성해야 한다.
    - 필드에 Collection 이 불가피하게 필요할 때 ConcurrentHashMap 사용 추천. synchronized 키워드가 적용된 범위가 좁아서 보다 좋은 성능을 낼 수 있는 자료구조이다.
- ThreadLocal
    - 스레드 사이에 간섭이 없어야 하는 데이터에 사용한다. 멀티스레드 환경에서는 클래스의 필드에 멤버를 추가할 수 없고 매개변수로 넘겨받아야 하기 때문이다. 즉, 스레드 내부의 싱글톤을 사용하기 위해 사용한다. 주로 사용자 인증, 세션 정보, 트랜잭션 컨텍스트에 사용한다.
    - 스레드 풀 환경에서 ThreadLocal 을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.
    - *T*hreadLocal 을 사용하는 방법
        1. ThreadLocal 객체를 생성한다.
        2. ThreadLocal.set() 메서드를 이용해서 현재 스레드의 로컬 변수에 값을 저장한다.
        3. ThreadLocal.get() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 읽어온다.
        4. ThreadLocal.remove() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 삭제한다.

# ****HashMap과 HashTable의 차이점****

- 공통점 : 유니크한 Key와 Value의 쌍을 저장하는 자바 Collection 객체
- 차이점
    - ****HashMap****
        
        null 저장 가능 
        
        내부적으로 보조 해시함수와 Seperate Chaining 방식을 사용하여 데이터를 저장하고 있기 때문에 Hashtable에 비해서 충돌이 덜 발생
        
         Key값을 순회하기 위해서 Iterator
        
    - ****HashTable****
        
        대부분의 연산에 synchronized 키워드를 붙여 명시적으로 동기화를 수행하기 때문에 멀티 스레드 환경에서 Thread Safe함을 보장
        
        객체를 저장할 때 hashCode를 구현한 객체만 저장할 수 있기 떄문에 null값 사용 불가능 
        
         Key값을 순회하기 위해서 Enumeration
        

# ****Collection****

- collection framework : 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 프레임워크
    - 컬렉션(collection) : 여러 객체(데이터)를 담을 수 있는 자료구조, 다수의 데이터 그룹
    - 프레임워크(framework) : 표준화, 정형화된 체계적인 프로그래밍 방
- 배열의 문제점을 해결
- 이미 구현되어 있는 것을 사용함으로써 코딩 시간을 감소시킬 수 있다. 컬렉션 프레임워크들은 잘 테스트되고 검증되어 있기 때문에 코드 품질을 보장

## **Collection Interface**

- 모든 컬렉션 클래스가 구현해야하는 메소드를 포함하고있다. ex) add, addAll, equals, isEmpty()..
- 제네릭(Generics)으로 표현되어 컴파일 시점에서 객체의 타입을 체크하기 때문에 런타임 에러를 줄이는 데 도움이 된다.
- java.util 패키지 안에 있음

1. set 인터페이스 : 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않습니다.
    1. HashSet : 가장 빠른 입의 접근 속도를 가지고 있으며, 순서를 예측할 수 없습니다.
    2. TreeSet : 중복된 데이터의 저장을 허용하지 않고 정렬된 위치에 저장하기때문에 저장순서를 유지하지 않습니다.
    3. LinkedHashSet : 추가된 순서, 또는 가장 최근에 접근한 순서대로 접근 가능합니다.
2. List 인터페이스 : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용합니다.
    1. LinkedList : 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번한 경우 데이터의 참조를 변경해주면 되기때문에 유용합니다 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰입니다.차
    2. Vector : 과거에 대용량 처리를 위해 사용했으며 ArrayList 클래스와 같은 동작을 수행하는 클래스입니다. 또한, 복수의 스레드로부터 추가/삭제 이루어 지더라도 내부의 데이터 처리는 안전하게 한번에 하나의 스레드만 처리되도록 보장함으로써 데이터 처리의 안정화의 이점이 있습니다. 하지만 단일 스레드 처리시에는 자동 동기화 보장(Thread-Safe)이 오히려 성능의 저하를 일으킬수 있기 때문에 단일 스레드에서는 ArrayList 가 더 효율적인 성능을 보장합니다.
    3. ArrayList : 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 조회 기능에 성능이 뛰어납니다.
3. Map 인터페이스 : 키, 값의 쌍으로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키의 중복을 허용하지 않지만 값의 중복은 허용합니다.
    1. HashTable : HashMap보다는 느리지만 동기화 지원합니다. 또한, Null은 불가능합니다.
    2. HashMap : Map 인터페이스를 구현하기 위해 해시테이블을 사용한 클래스로 중복과 순서가 허용되지 않으며 null값이 올 수 있습니다.
    3. TreeMap : 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장합니다. 또한, 정렬된 순서대로 키(Key)와 값(Value)을 저장하여 검색이 빠르지만, 저장시 Key값의 타입에 따라 기본 정렬방식을 사용하여 정렬한 뒤 저장하여 저장시간이 다소 오래걸립니다.
    4. LinkedHashMap : 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사합니다. Map에 있는 엔트리들의 연결 리스트를 유지되므로 입력한 순서대로 반복 가능합니다.

### ****HashSet과 TreeSet의 차이점****

- HashSet
    
    Set 인터페이스의 구현 클래스 
    
    객체들을 순서 없이 저장하고 중복 저장하지 않습니다.
    
    HashSet에서의 동일한 객체는 꼭 같은 인스턴스를 뜻하지는 않으며 객체를 저장하기 전에 객체의 hashCode() 메소를 호출해 해시코드를 얻어낸 뒤 저장되어 있는 객체 중 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않습니다.
    
- TresSet
    
    Set 컬렉션의 검색 기능을 강화시킨 컬렉션 
    
    이진 트리 구조를 사용하여 tree 구조를 가지면서 객체를 저장
    
    TreeSet 각각의 노드는 노드값인 value와 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두개의 변수로 구성됩니다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은 값은 왼쪽 자식 노드에 , 높은 것은 오른쪽 자식 노드에 저장하게 됩니다.
    
- 같은 Set 컬렉션이지만 HashSet과 TreeSet의 차이점은 HashSet은 해시테이블을 이용하여 구현하기 때문에 그 요소들이 정렬되지 않습니다. 또한 HashSet의 add, remove, contains 메소드는 일정한 시간복잡도인 O(1)을 갖습니다. 반면에 TreeSet은 각각의 요소들을 자동으로 정렬시키며 add, remove, contains 메소드의 시간복잡도가 O(logN)을 갖게 됩니다.

# **동일성(identity)과 동등성(equality)**

- ==는 대상의 주소값을 비교하고 equals()은 대상의 내용 자체를 비교한다

# ****기본형과 참조형의 차이점****

- 기본형(Primitive Type)
    - 변수에 값 자체를 저장하며, stack 영역에 생성된다.
    - 사용하기 전에 반드시 선언되어야 하며, 초기화를 하지 않으면 자료형에 맞는 기본 값이 들어간다.
    - OS에 따라 자료의 길이가 변하지 않는다.
    - 비객체 타입이며, Null 값을 가질 수 없다.
    - 정수(byte, short, int, long), 실수(double, float), 문자(char), 논리(boolean)
- 참조형(Reference Type)
    - 기본형을 제외하면 참조형이라고 한다.
    - Object 클래스이거나 이를 상속하는 클래스들
    - 메모리 상에서 객체가 존재하는 주소를 저장하며, heap 영역에 저장한다.
    - 클래스형, 인터페이스형, 배열형이 있다.

# ****전역, 지역, 클래스 변수를 자바의 메모리 구조****

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/00fecf97-7b1d-432e-bc84-98f60757e488/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220305%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220305T143913Z&X-Amz-Expires=86400&X-Amz-Signature=0625a94e5dd4beead0bacd6a44a60f70a495b952dad7f67fdc7bb2848b4b4350&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)

1. 메소드 영역
    - 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역.
    - JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)을 읽어들여, 클래스에 대한 정보를 메소드 영역에 저장한다.
2. 힙 영역
    - 모든 인스턴스 변수(멤버 변수)가 저장되는 영역.
    - new 키워드를 사용해 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장한다.
    - 힙 영역은 메모리의 낮은 주소 -> 높은 주소의 방향으로 할당된다.
3. 스택 영역
    - 메소드가 호출될 때, 메소드의 스택 프레임이 저장되는 영역.
    - 메소드 호출 시, 메소드 호출과 관계되는 매개변수와 지역 변수를 스택 영역에 저장한다.
    - 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸한다.
    - 스택 영역에 저장되는 메소드의 호출 정보를 **스택 프레임**이라고 부른다.
    - 후입 선출의 구조를 갖고 있으며, 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

# ****Reflection****

- 이미 로딩이 완료된 클래스에서 또는 다른 클래스를 동적으로 로딩하여 구체적인 타입을 알지 못하더라도 생성자, 멤버 필드, 그리고 멤버 메소드를 사용할 수 있는 기법. 즉, 컴파일 타임이 아니라 **런타임에 동적**으로 특정 클래스의 정보를 객체화하여 분석 및 추출해낼 수 있는 프로그래밍 기법
- 사용 이유
    - 실행 시간(Runtime)에 다른 클래스를 동적으로 로딩하여 접근할 필요가 있을 때.
    - 클래스와 멤버 필드 그리고 메소드 등에 관한 정보를 얻어야할 때.
    - 리플렉션 없이도 완성도 높은 코드를 구현할 수 있지만, 사용한다면 조금 더 유연한 코드를 만들 수 있다.

# ****Thread****

- 스레드 : 하나의 작업 단위.
- 스레드를 구현하는 방법은 Runnable 인터페이스 구현, Thread 클래스 상속 두가지가 있으며 두 방식 모두 run() 메소드를 오버라이딩 한다.
    - Runnable 인터페이스 : run() 메소드를 오버라이드하고 Runnable 인터페이스를 구현한 클래스의 객체를 만들어 Thread를 생성할 때, 생성자의 매개변수로 넘겨준다.
    - Thread 클래스 상속 : run() 메소드를 직접 구현해야 한다. 스레드 클래스의 메소드를 바로 사용할 수 있다.
    
    ```java
    public class MyThread implements Runnable {
      @Override
      public void run(){
        // 수행 코드.
      }
    }
    
    Runnable runnable = new MyThread();
    Thread t = new Thread(runnable, "mythread");
    ```
    
- 스레드의 실행은 run() 호출이 아닌 start() 호출로 해야 한다
    
    run() 메소드를 이용한다는 것은 main()의 콜 스택 하나만 이용하는 것으로 스레드 활용이 아니다. 그냥 스레드 객체의 run이라는 메소드를 호출하는 것 뿐이게 된다. start() 메소드를 호출하면 JVM은 스레드가 작업을 실행하는 데 필요한 콜 스택을 생성한 다음 run()을 호출해서 그 스택 안에 run()을 저장할 수 있도록 해준다.
    
- 스레드는 다음과 같이 5가지의 상태를 가지고 있다.
    1. NEW : 스레드가 생성되고 아직 start()가 호출되지 않은 상태
    2. RUNNABLE : 실행 중 또는 실행 가능 상태
    3. BLOCKED : 동기화 블록에 의해 일시정지된 상태(lock이 풀릴 때까지 기다림)
    4. WAITING, TIME_WAITING : 실행 가능하지 않은 일시정지 상태
    5. TERMINATED : 스레드 작업이 종료된 상태
- 멀티 스레딩 : 하나의 프로스세 안에서 여러 개의 스레드가 동시에 작업을 수행하는 것
- 멀티스레드 동기화
    - 멀티스레드로 구현을 하다보면, 동기화는 필수적이다. 동기화가 필요한 이유는, **여러 스레드가 같은 프로세스 내의 자원을 공유하면서 작업할 때 서로의 작업이 다른 작업에 영향을 주기 때문**이다. 스레드의 동기화를 위해선, 임계 영역(critical section)과 잠금(lock)을 활용한다. 임계영역을 지정하고, 임계영역을 가지고 있는 lock을 단 하나의 스레드에게만 빌려주는 개념으로 이루어져있다. 따라서 임계구역 안에서 수행할 코드가 완료되면, lock을 반납해줘야 한다.
    - ****synchronized : 임계영역을 설정****
    - ****wait()과 notify()****
        - ****동기화 된 영역(임계 영역)내에서 사용****
        - 스레드가 서로 협력관계일 경우에는 무작정 대기시키는 것으로 올바르게 실행되지 않기 때문에 사용한다
        - wait() : 스레드가 lock을 가지고 있으면, lock 권한을 반납하고 대기하게 만듬
        - notify() : 대기 상태인 스레드에게 다시 lock 권한을 부여하고 수행하게 만듬
        - 
- **스레드 동기화 방법**
    - 임계 영역(critical section) : 공유 자원에 단 하나의 스레드만 접근하도록(하나의 프로세스에 속한 스레드만 가능)
    - 뮤텍스(mutex) : 공유 자원에 단 하나의 스레드만 접근하도록(서로 다른 프로세스에 속한 스레드도 가능)
    - 이벤트(event) : 특정한 사건 발생을 다른 스레드에게 알림
    - 세마포어(semaphore) : 한정된 개수의 자원을 여러 스레드가 사용하려고 할 때 접근 제한
    - 대기 가능 타이머(waitable timer) : 특정 시간이 되면 대기 중이던 스레드 깨움

# Checked Exception과 Unchecked Exception

- 둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다. RuntimeException을 상속하면 UncheckedException이 됩니다. 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.

# Java8에서 추가된 기능

- Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가되었습니다. lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다. Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다. 날짜 시간 API는 Joda-time등의 라이브러리에서 영향을 받아 괜찮은 API가 되었으며, StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.

# try-with-resources

- 버전7에 도입된 문법
- try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, try 블록 안에서 로직이 정상적으로 완료되었는지 여부와 관계 없이 JVM에서 자동으로 자원을 반납해주는 기능
- 추가로, 자바 9 버전에서는 try() 문 안에 명시적으로 객체 선언을 하기 보다는 try 문 바깥에서 객체 선언을 하고 생성된 인스턴스의 변수를 넣어줄 수 있도록 바뀌었습니다.
    
    Java 7 : try(BufferedReader br = new BufferedReader())Java 9 : try(br)
    

# 직렬화와 역직렬화

- 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 변환하는 기술(역직렬화)을 아울러서 이야기 합니다.
- 자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용됩니다. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.

# 동기화와 비동기화의 차이(Syncronous vs Asyncronous)

# Stream

# Lambda

# ****Casting(업캐스팅 & 다운캐스팅)****

- **캐스팅이 필요한 이유는?**
    1. **다형성** : 오버라이딩된 함수를 분리해서 활용할 수 있다.
    2. **상속** : 캐스팅을 통해 범용적인 프로그래밍이 가능하다.
- **형변환의 종류**
    1. **묵시적 형변환** : 캐스팅이 자동으로 발생 (업캐스팅)
        
        `Parent p = new Child(); // (Parent) new Child()할 필요가 없음`
        
        > Parent를 상속받은 Child는 Parent의 속성을 포함하고 있기 때문
        > 
    2. **명시적 형변환** : 캐스팅할 내용을 적어줘야 하는 경우 (다운캐스팅)
        
        `Parent p = new Child();
        Child c = (Child) p;`
        
        > 다운캐스팅은 업캐스팅이 발생한 이후에 작용한다.
        > 

# ****Thread****

# ****고유 락 (Intrinsic Lock)****

- Intrinsic Lock (= monitor lock = monitor)
    - Java의 모든 객체는 lock을 갖고 있음.
- *Synchronized block*
    - *Intrinsic Lock을 이용해서, Thread의 접근을 제어함.*
- **Reentrancy**
    - Lock을 획득한 Thread가 같은 Lock을 얻기 위해 대기할 필요가 없는 것
- ****Structured Lock vs Reentrant Lock****
    - **Structured Lock (구조적 Lock) : 고유 lock을 이용한 동기화**
        
        (Synchronized 블록 단위로 lock의 획득 / 해제가 일어나므로)
        
        따라서,
        
        A획득 -> B획득 -> B해제 -> A해제는 가능하지만,
        
        A획득 -> B획득 -> A해제 -> B해제는 불가능함.
        
        이것을 가능하게 하기 위해서는 **Reentrant Lock (명시적 Lock) 을 사용**해야 함.
        
- ****Visibility****
    - 가시성 : 여러 Thread가 동시에 작동하였을 때, 한 Thread가 쓴 값을 다른 Thread가 볼 수 있는지, 없는지 여부
    - 문제 : 하나의 Thread가 쓴 값을 다른 Thread가 볼 수 있느냐 없느냐. (볼 수 없으면 문제가 됨)
    - Lock : Structure Lock과 Reentrant Lock은 Visibility를 보장.
    - 원인 :
        1. 최적화를 위해 Compiler나 CPU에서 발생하는 코드 재배열로 인해서.
        2. CPU core의 cache 값이 Memory에 제때 쓰이지 않아 발생하는 문제.
