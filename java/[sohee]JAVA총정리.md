
# ****String, StringBuffer, StringBuilder의 차이****

- JAVA에는 문자열 클래스로 String, StringBuffer, StringBuilder 3가지가 있습니다

## String

- String은 Heap에 저장되고 Immutable(불변성) 특징을 갖고 있다.
- String은 immutable하기 때문에 'Hi'라는 새로운 객체를 만든다!
- literal로 생성된 객체는 string constant pool에 저장된다. pool 내에 같은 문자열이 있다면 해당 주소를 할당한다.
- 생성 방식
    - new
    - literal
    
    new 연산자로 생성하면 Heap에 존재하게 되고 리터럴을 이용하면 string constant pool 이라는 영역에 존재 
    
- intern() 메서드 : new를 통해 생성된 String객체라 하더라도 string constant pool 내부에 있는 문자열을 검색해 해당 주소값을 반환

## ****StringBuffer와 StringBuilder****

- StringBuffer와 StringBuilder는 mutable한 특성을 갖는다.
- StringBuffer는 동기식이고 StringBuilder는 비동기식이다.
- 단순히 속도적인 측면만 봤을 때는 StringBuilder가 다소 빠르다.
- 초기 생성할 때 Buffer Size를 설정할 수 있는데 이에 의한 생성, 확장 오버로드가 생길 수 있기 때문에 Buffer Size를 잘못 지정할 경우 성능이 떨어질 수도 있다.

# ****HashMap과 HashTable****

- Map 인터페이스를 상속받고 Key-Value 구조를 갖는다.
- Hashtable은 동기화를 지원하고 HashMap은 동기화를 지원하지 않는다.
    
    즉, **멀티 스레드 환경에서는 Hashtable**을 사용해야 한다. HashMap을 동기화 하려면 ConcurrentHashMap을 사용하면 된다.
    
- HashMap이 다소 속도가 빠르다. Hashtable은 동기화 처리 비용이 있기 때문이다.
- HashMap은 저장된 요소들의 순회를 위해 Iterator를 반환한다. Hashtable은 Enumeration을 반환한다.

# final

### **Final variable**

- 변수의 값을 **상수**로 지정

### **Final method**

- **오버라이딩 불가**
- 예를 들어 부모 클래스에서 speak() 메소드가 입으로 말하도록 정의했는데 자식 클래스에서 재정의하여 손으로 말하도록 기능을 바꿀 수 없게

### **Final class**

- **상속 불가**
- 클래스 내부의 메소드도 오버라이딩 불가
- 대표적으로 String class
- 중요한 어떤 class에 대해 sub class로 시스템이 파괴될 수 있기 때문에 자바에서는 핵심 class에 대해 final class로 선언하고 있다.

# ****Interface와 abstract의 차이****

## ****Interface****

- 일종의 추상클래스이다. 오직 **추상메소드와 상수만**을 멤버로 가질 수 있다.
- 인터페이스를 쓰는 이유
    - 완벽한 추상화를 이루기 위해(메소드 구현 목적) / 다중 상속 다형성

## ****Abstract****

- 추상 메소드 ********
    - 메소드의 정의만 되어있는 비어있는 메소드
- 추상 클래스
    - 추상 메소드를 하나라도 포함하고 있는 클래스는 추상 클래스가 된다.
    - 추상 클래스만으로 새로운 인스턴스(객체)를 생성할 수 없다.
    - 멤버 변수와 구현된 메소드가 존재 가능
    - 다중 상속 불가

# OOP

- 프로그래밍에서 필요한 데이터를 추상화시켜서 상태(변수)와 행위(메소드)를 가진 객체를 만들고 **이 객체들간의 유기적인 상호작용으로 로직을 구성**하는 프로그래밍 방법
- 장점
    - 코드의 재사용 용이 / 유지보수가 쉬움 / 대형 프로젝트에 적합(모듈화)
- 단점
    - 처리속도가 상대적으로 느림 / 객체가 많으면 용량이 커질 수 있음 / 설계시 많은 시간과 노력이 필요
- 특징
    
    ### **1. 추상화**
    
    - 공통의 속성이나 기능을 묶어 이름을 붙이는 것
    - 클래스를 정의하는 것
    
    ### **2. 캡슐화**
    
    - 관련있는 변수와 메소드를 묶어주는 것
    - (JAVA)접근 제어 지시자를 통해 외부 접근을 제한하며 이를 정보은닉이라고 함
    
    ### **3. 상속**
    
    - 자식클래스는 상속을 통해 부모클래스의 속성과 기능을 물려받음
    - 상속받은 기능의 일부를 수정하여 사용 가능
    
    ### **4. 다형성**
    
    - 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석되는 것
    - 오버로딩, 오버라이딩 개념
    - **오버로딩**
        - 같은 클래스 내에서 동일한 이름의 함수를 여러 개 정의하고 매개 변수의 타입과 개수를 다르게 하는 것.
        - 정적 바인딩된다.
    - **오버라이딩**
        - 상위 클래스 혹은 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다.
        - 동적 바인딩된다.

# ****객체지향 5대원칙(SOLID)****

- 객체지향을 설계할때 지키면 좋은 원칙

### **Single Responsiblity Principle (SRP, 단일 책임 원칙)**

- 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임(기능)만을 가져야 한다.
- 응집도는 높고 결합도는 낮게

### **Open-Closed Principle (OCP, 개방-패쇄 원칙)**

- 객체는 **확장**에 대해서는 **개방적**이고 **수정**에 대해서는 **폐쇄적**이어야 한다는 원칙이다.
- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 한다.
- 대표적인 문법이 인터페이스(Interface)이다.

### **Liskov Substitution Principle (LSP, 리스코프 치환 원칙)**

- **자식 클래스**는 언제나 자신의 **부모 클래스**를 **대체**할 수 있다는 원칙이다.
- 자식 클래스는 부모 클래스의 기능을 수행할 수 있어야 한다.

### **Interface Segregation Principle (ISP, 인터페이스 분리 원칙)**

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.

### **Dependency Inversion Principle (DIP, 의존 역전 원칙)**

- 상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안된다는 원칙이다
- 추상화 된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.
- 의존관계를 맺을 때, 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미한다.
- DIP를 만족하면 '의존성 주입(DI)' 기술로 변화에 유연한 설계를 할 수 있다.

# ****접근 제한자 (Access Modifier)****

- public
    - 어떤 클래스에서도 접근이 가능하다.
- protected
    - 클래스가 정의되어 있는 해당 패키지 내 그리고 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근이 가능하다.
- private
    - 클래스의 내부에서만 접근 가능
- default
    - 아무것도 선언하지 않았을 때 기본
    - 같은 패키지에서 접근 가능

# ****Collection****

- 다수의 Data 를 다루는데 표준화된 클래스들을 제공해주기 때문에 DataStructure 를 직접 구현하지 않고 편하게 사용할 수 있다
- 공간을 미리 정하지 않아도 되므로, 상황에 따라 객체의 수를 동적으로 정할 수 있다.
- List
List 인터페이스를 직접 @Override를 통해 사용자가 정의하여 사용할 수도 있으며, 대표적인 구현체로는 ArrayList가 존재한다. 이는 기존에 있었던 Vector를 개선한 것이다. 이외에도 LinkedList 등의 구현체가 있다.
- Map
대표적인 구현체로 HashMap이 존재한다. key-value 의 구조로 이루어져 있으며 Map 에 대한 구체적인 내용은 DataStructure 부분의 hashtable 과 일치한다. key 를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않는다. key 에 대해서 순서를 보장하기 위해서는 LinkedHashMap을 사용한다.
- Set
대표적인 구현체로 HashSet이 존재한다. value에 대해서 중복된 값을 저장하지 않는다. 사실 Set 자료구조는 Map 의 key-value 구조에서 key 대신에 value 가 들어가 value 를 key 로 하는 자료구조일 뿐이다. 마찬가지로 순서를 보장하지 않으며 순서를 보장해주기 위해서는 LinkedHashSet을 사용한다.
- Stack 과 Queue
Stack 객체는 직접 new 키워드로 사용할 수 있으며, Queue 인터페이스는 JDK 1.5 부터 LinkedList에 new 키워드를 적용하여 사용할 수 있다.

# ****Annotation****

- 어노테이션이란 본래 주석이란 뜻으로, 인터페이스를 기반으로 한 문법이다. 주석과는 그 역할이 다르지만 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입할 수 있다. 또 해석되는 시점을 정할 수도 있다.(Retention Policy)
- 종류
    - built-in annotation : JDK 에 내장되어 있는 어노테이션 ex) @Override
    - Meta annotation : 어노테이션에 대한 정보를 나타내기 위한 어노테이션
    - Custom Annotation : 그리고 개발자가 직접 만들어 내는 어노테이션

# ****Generic****

- 제네릭은 자바에서 안정성을 맡고 있다고 할 수 있다. 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움을 줄여준다.

# ****Multi-Thread 환경에서의 개발****

- Field member
    - 객체가 여러 스레드가 접근하는 싱글톤 객체라면 field 에서 상태값을 갖고 있으면 안된다. 모든 변수를 parameter 로 넘겨받고 return 하는 방식으로 코드를 구성해야 한다.
    - 필드에 Collection 이 불가피하게 필요할 때 ConcurrentHashMap 사용 추천. synchronized 키워드가 적용된 범위가 좁아서 보다 좋은 성능을 낼 수 있는 자료구조이다.
- ThreadLocal
    - 스레드 사이에 간섭이 없어야 하는 데이터에 사용한다. 멀티스레드 환경에서는 클래스의 필드에 멤버를 추가할 수 없고 매개변수로 넘겨받아야 하기 때문이다. 즉, 스레드 내부의 싱글톤을 사용하기 위해 사용한다. 주로 사용자 인증, 세션 정보, 트랜잭션 컨텍스트에 사용한다.
    - 스레드 풀 환경에서 ThreadLocal 을 사용하는 경우 ThreadLocal 변수에 보관된 데이터의 사용이 끝나면 반드시 해당 데이터를 삭제해 주어야 한다. 그렇지 않을 경우 재사용되는 쓰레드가 올바르지 않은 데이터를 참조할 수 있다.
    - *T*hreadLocal 을 사용하는 방법
        1. ThreadLocal 객체를 생성한다.
        2. ThreadLocal.set() 메서드를 이용해서 현재 스레드의 로컬 변수에 값을 저장한다.
        3. ThreadLocal.get() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 읽어온다.
        4. ThreadLocal.remove() 메서드를 이용해서 현재 스레드의 로컬 변수 값을 삭제한다.

# ****HashMap과 HashTable의 차이점****

- 공통점 : 유니크한 Key와 Value의 쌍을 저장하는 자바 Collection 객체
- 차이점
    - ****HashMap****
        
        null 저장 가능 
        
        내부적으로 보조 해시함수와 Seperate Chaining 방식을 사용하여 데이터를 저장하고 있기 때문에 Hashtable에 비해서 충돌이 덜 발생
        
         Key값을 순회하기 위해서 Iterator
        
    - ****HashTable****
        
        대부분의 연산에 synchronized 키워드를 붙여 명시적으로 동기화를 수행하기 때문에 멀티 스레드 환경에서 Thread Safe함을 보장
        
        객체를 저장할 때 hashCode를 구현한 객체만 저장할 수 있기 떄문에 null값 사용 불가능 
        
         Key값을 순회하기 위해서 Enumeration
        

# ****Collection****

- collection framework : 다수의 객체를 쉽게 처리할 수 있게 도와주는 방식
    - 컬렉션(collection) : 여러 객체(데이터)를 담을 수 있는 자료구조, 다수의 데이터 그룹
    - 프레임워크(framework) : 표준화, 정형화된 체계적인 프로그래밍 방식
- 배열의 문제점을 해결
- 이미 구현되어 있는 것을 사용함으로써 코딩 시간을 감소시킬 수 있다. 컬렉션 프레임워크들은 잘 테스트되고 검증되어 있기 때문에 코드 품질을 보장

## **Collection Interface**

- 모든 컬렉션 클래스가 구현해야하는 메소드를 포함하고있다. ex) add, addAll, equals, isEmpty()..
- 제네릭(Generics)으로 표현되어 컴파일 시점에서 객체의 타입을 체크하기 때문에 런타임 에러를 줄이는 데 도움이 된다.
- java.util 패키지 안에 있음

1. set 인터페이스 : 순서를 유지하지 않는 데이터의 집합으로 데이터의 중복을 허용하지 않습니다.
    1. HashSet : 가장 빠른 입의 접근 속도를 가지고 있으며, 순서를 예측할 수 없습니다.
    2. TreeSet : 중복된 데이터의 저장을 허용하지 않고 정렬된 위치에 저장하기때문에 저장순서를 유지하지 않습니다.
    3. LinkedHashSet : 추가된 순서, 또는 가장 최근에 접근한 순서대로 접근 가능합니다.
2. List 인터페이스 : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용합니다.
    1. LinkedList : 양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번한 경우 데이터의 참조를 변경해주면 되기때문에 유용합니다 스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰입니다.
    2. Vector : 과거에 대용량 처리를 위해 사용했으며 ArrayList 클래스와 같은 동작을 수행하는 클래스입니다. 또한, 복수의 스레드로부터 추가/삭제 이루어 지더라도 내부의 데이터 처리는 안전하게 한번에 하나의 스레드만 처리되도록 보장함으로써 데이터 처리의 안정화의 이점이 있습니다. 하지만 단일 스레드 처리시에는 자동 동기화 보장(Thread-Safe)이 오히려 성능의 저하를 일으킬수 있기 때문에 단일 스레드에서는 ArrayList 가 더 효율적인 성능을 보장합니다.
    3. ArrayList : 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 조회 기능에 성능이 뛰어납니다.
3. Map 인터페이스 : 키, 값의 쌍으로 이루어진 데이터의 집합으로 순서는 유지되지 않으며, 키의 중복을 허용하지 않지만 값의 중복은 허용합니다.
    1. HashTable : HashMap보다는 느리지만 동기화 지원합니다. 또한, Null은 불가능합니다.
    2. HashMap : Map 인터페이스를 구현하기 위해 해시테이블을 사용한 클래스로 중복과 순서가 허용되지 않으며 null값이 올 수 있습니다.
    3. TreeMap : 이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장합니다. 또한, 정렬된 순서대로 키(Key)와 값(Value)을 저장하여 검색이 빠르지만, 저장시 Key값의 타입에 따라 기본 정렬방식을 사용하여 정렬한 뒤 저장하여 저장시간이 다소 오래걸립니다.
    4. LinkedHashMap : 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사합니다. Map에 있는 엔트리들의 연결 리스트를 유지되므로 입력한 순서대로 반복 가능합니다.

### ****HashSet과 TreeSet의 차이점****

- HashSet
    
    Set 인터페이스의 구현 클래스 
    
    객체들을 순서 없이 저장하고 중복 저장하지 않습니다.
    
    HashSet에서의 동일한 객체는 꼭 같은 인스턴스를 뜻하지는 않으며 객체를 저장하기 전에 객체의 hashCode() 메소를 호출해 해시코드를 얻어낸 뒤 저장되어 있는 객체 중 동일한 해시코드가 있다면 다시 equals() 메소드로 두 객체를 비교해 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않습니다.
    
- TresSet
    
    Set 컬렉션의 검색 기능을 강화시킨 컬렉션 
    
    이진 트리 구조를 사용하여 tree 구조를 가지면서 객체를 저장
    
    TreeSet 각각의 노드는 노드값인 value와 왼쪽과 오른쪽 자식 노드를 참조하기 위한 두개의 변수로 구성됩니다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모값과 비교해서 낮은 값은 왼쪽 자식 노드에 , 높은 것은 오른쪽 자식 노드에 저장하게 됩니다.
    
- 같은 Set 컬렉션이지만 HashSet과 TreeSet의 차이점은 HashSet은 해시테이블을 이용하여 구현하기 때문에 그 요소들이 정렬되지 않습니다. 또한 HashSet의 add, remove, contains 메소드는 일정한 시간복잡도인 O(1)을 갖습니다. 반면에 TreeSet은 각각의 요소들을 자동으로 정렬시키며 add, remove, contains 메소드의 시간복잡도가 O(logN)을 갖게 됩니다.
